"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.requireSiblingColumn = exports.requireChildColumn = exports.requireColumn = exports.makeFieldHelpers = void 0;
const debug_1 = require("debug");
const graphile_build_pg_1 = require("graphile-build-pg");
// Not really the right scope, but eases debugging for users
const debugSql = debug_1.default("graphile-build-pg:sql");
function makeFieldHelpers(build, fieldContext, context, resolveInfo) {
    const { parseResolveInfo, pgQueryFromResolveData, pgSql: sql } = build;
    const { getDataFromParsedResolveInfoFragment, scope } = fieldContext;
    const { pgFieldIntrospection, isPgFieldConnection } = scope;
    const isConnection = !!isPgFieldConnection;
    const table = pgFieldIntrospection && pgFieldIntrospection.kind === "class"
        ? pgFieldIntrospection
        : null;
    const primaryKeyConstraint = table && table.primaryKeyConstraint;
    const primaryKeys = primaryKeyConstraint && primaryKeyConstraint.keyAttributes;
    const selectGraphQLResultFromTable = async (tableFragment, builderCallback) => {
        const { pgClient } = context;
        const parsedResolveInfoFragment = parseResolveInfo(resolveInfo);
        const PayloadType = resolveInfo.returnType;
        const resolveData = getDataFromParsedResolveInfoFragment(parsedResolveInfoFragment, PayloadType);
        const tableAlias = sql.identifier(Symbol());
        const query = pgQueryFromResolveData(tableFragment, tableAlias, resolveData, {
            withPaginationAsFields: isConnection,
        }, (sqlBuilder) => {
            if (!isConnection &&
                primaryKeys &&
                build.options.subscriptions &&
                table) {
                sqlBuilder.selectIdentifiers(table);
            }
            if (typeof builderCallback === "function") {
                builderCallback(tableAlias, sqlBuilder);
            }
        }, context, resolveInfo.rootValue);
        const { text, values } = sql.compile(query);
        if (debugSql.enabled)
            debugSql("%s", "\n" + graphile_build_pg_1.formatSQLForDebugging(text));
        const { rows } = await pgClient.query(text, values);
        if (isConnection) {
            return build.pgAddStartEndCursor(rows[0]);
        }
        else {
            const liveRecord = resolveInfo.rootValue && resolveInfo.rootValue.liveRecord;
            if (build.options.subscriptions &&
                !isConnection &&
                primaryKeys &&
                liveRecord) {
                rows.forEach((row) => row && liveRecord("pg", table, row.__identifiers));
            }
            return rows;
        }
    };
    const graphileHelpers = {
        build,
        fieldContext,
        selectGraphQLResultFromTable,
    };
    return graphileHelpers;
}
exports.makeFieldHelpers = makeFieldHelpers;
function requireColumn(build, context, method, col, alias) {
    const { pgSql: sql } = build;
    context[method](() => ({
        pgQuery: (queryBuilder) => {
            queryBuilder.select(sql.query `${queryBuilder.getTableAlias()}.${sql.identifier(col)}`, alias);
        },
    }));
}
exports.requireColumn = requireColumn;
function requireChildColumn(build, context, col, alias) {
    return requireColumn(build, context, "addArgDataGenerator", col, alias);
}
exports.requireChildColumn = requireChildColumn;
function requireSiblingColumn(build, context, col, alias) {
    return requireColumn(build, context, "addDataGenerator", col, alias);
}
exports.requireSiblingColumn = requireSiblingColumn;
//# sourceMappingURL=fieldHelpers.js.map