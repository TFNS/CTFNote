"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeJSONPgSmartTagsPlugin = exports.makePgSmartTagsPlugin = void 0;
const tslib_1 = require("tslib");
const graphile_build_pg_1 = require("graphile-build-pg");
const util_1 = require("util");
const introspectionHelpers_1 = require("./introspectionHelpers");
const meaningByKind = {
    [graphile_build_pg_1.PgEntityKind.CLASS]: "for tables, composite types, views and materialized views",
    [graphile_build_pg_1.PgEntityKind.ATTRIBUTE]: "for columns/attributes (of any 'class' type)",
    [graphile_build_pg_1.PgEntityKind.CONSTRAINT]: "for table constraints",
    [graphile_build_pg_1.PgEntityKind.PROCEDURE]: "for functions/procedures",
};
const validKinds = Object.entries(meaningByKind)
    .map(([kind, meaning]) => `'${kind}' (${meaning})`)
    .join(", ");
function compileRule(rule) {
    const { kind, match: incomingMatch } = rule, rest = tslib_1.__rest(rule, ["kind", "match"]);
    if (!Object.prototype.hasOwnProperty.call(meaningByKind, kind)) {
        throw new Error(`makePgSmartTagsPlugin rule has invalid kind '${kind}'; valid kinds are: ${validKinds}`);
    }
    const match = (obj, build) => {
        if (obj.kind !== kind) {
            return false;
        }
        if (typeof incomingMatch === "function") {
            // User supplied a match function; delegate to that:
            return incomingMatch(obj, build);
        }
        else if (typeof incomingMatch === "string") {
            // It's a fully-qualified case-sensitive name of the thing.
            return introspectionHelpers_1.entityIsIdentifiedBy(obj, incomingMatch, build);
        }
        else {
            throw new Error("makePgSmartTagsPlugin rule 'match' is neither a string nor a function");
        }
    };
    return Object.assign({ kind,
        match }, rest);
}
function rulesFrom(ruleOrRules) {
    const rawRules = Array.isArray(ruleOrRules)
        ? ruleOrRules
        : ruleOrRules
            ? [ruleOrRules]
            : [];
    return [rawRules.map(compileRule), rawRules];
}
function makePgSmartTagsPlugin(ruleOrRules, subscribeToUpdatesCallback) {
    let [rules, rawRules] = rulesFrom(ruleOrRules);
    const plugin = (builder, _options) => {
        if (subscribeToUpdatesCallback) {
            builder.registerWatcher(async (triggerRebuild) => {
                await subscribeToUpdatesCallback(newRuleOrRules => {
                    [rules, rawRules] = rulesFrom(newRuleOrRules);
                    triggerRebuild();
                });
            }, async () => {
                await subscribeToUpdatesCallback(null);
            });
        }
        builder.hook("build", build => {
            const oldPgAugmentIntrospectionResults = build.pgAugmentIntrospectionResults;
            build.pgAugmentIntrospectionResults = (inIntrospectionResult) => {
                let pgIntrospectionResultsByKind = inIntrospectionResult;
                if (oldPgAugmentIntrospectionResults) {
                    pgIntrospectionResultsByKind = oldPgAugmentIntrospectionResults(pgIntrospectionResultsByKind);
                }
                /**
                 * The introspection results aren't currently on Build (we're helping
                 * this happen now!), so we're going to fake it to make the API more
                 * straightforward
                 */
                const buildWithIntrospection = Object.assign(Object.assign({}, build), { pgIntrospectionResultsByKind });
                rules.forEach((rule, idx) => {
                    const relevantIntrospectionResults = pgIntrospectionResultsByKind[rule.kind];
                    let hits = 0;
                    relevantIntrospectionResults.forEach(entity => {
                        if (!rule.match(entity, buildWithIntrospection)) {
                            return;
                        }
                        hits++;
                        if (rule.tags) {
                            // Overwrite relevant tags
                            Object.assign(entity.tags, rule.tags);
                        }
                        if (rule.description != null) {
                            // Overwrite comment if specified
                            entity.description = rule.description;
                        }
                    });
                    // Let people know if their rules don't match; it's probably a mistake.
                    if (hits === 0) {
                        console.warn(`WARNING: there were no matches for makePgSmartTagsPlugin rule ${idx} - ${util_1.inspect(rawRules[idx])}`);
                    }
                });
                return pgIntrospectionResultsByKind;
            };
            return build;
        }, [], ["PgIntrospection"], ["PgBasics"]);
    };
    return plugin;
}
exports.makePgSmartTagsPlugin = makePgSmartTagsPlugin;
function pgSmartTagRulesFromJSON(json) {
    if (!json) {
        return [];
    }
    if (json.version !== 1) {
        throw new Error('This version of graphile-utils only supports the version 1 smart tags JSON format; e.g. `{version: 1, config: { class: { my_table: { tags: { omit: "create,update,delete" } } } } }`');
    }
    const specByIdentifierByKind = json.config;
    const rules = [];
    function process(kind, identifier, subKind, obj, key, deprecated = false) {
        if (kind !== graphile_build_pg_1.PgEntityKind.CLASS) {
            throw new Error(`makeJSONPgSmartTagsPlugin: '${key}' is only valid on a class; you tried to set it on a '${kind}' at 'config.${kind}.${identifier}.${key}'`);
        }
        const path = `config.${kind}.${identifier}.${key}`;
        if (deprecated) {
            console.warn(`Tags JSON path '${path}' is deprecated, please use 'config.${kind}.${identifier}.attribute' instead`);
        }
        if (typeof obj !== "object" || obj == null) {
            throw new Error(`Invalid value for '${path}'`);
        }
        const entities = obj;
        for (const entityName of Object.keys(entities)) {
            if (entityName.includes(".")) {
                throw new Error(`${key} '${entityName}' should not contain a period at '${path}'. This nested entry does not need further description.`);
            }
            const entitySpec = entities[entityName];
            const { tags: entityTags, description: entityDescription } = entitySpec, entityRest = tslib_1.__rest(entitySpec, ["tags", "description"]);
            if (Object.keys(entityRest).length > 0) {
                console.warn(`WARNING: makeJSONPgSmartTagsPlugin '${key}' only supports 'tags' and 'description' currently, you have also set '${Object.keys(entityRest).join("', '")}' at '${path}.${entityName}'. Perhaps you forgot to add a "tags" entry containing these keys?`);
            }
            rules.push({
                kind: subKind,
                match: `${identifier}.${entityName}`,
                tags: entityTags,
                description: entityDescription,
            });
        }
    }
    for (const rawKind of Object.keys(specByIdentifierByKind)) {
        if (!Object.prototype.hasOwnProperty.call(meaningByKind, rawKind)) {
            throw new Error(`makeJSONPgSmartTagsPlugin JSON rule has invalid kind '${rawKind}'; valid kinds are: ${validKinds}`);
        }
        const kind = rawKind;
        const specByIdentifier = specByIdentifierByKind[kind];
        for (const identifier of Object.keys(specByIdentifier)) {
            const spec = specByIdentifier[identifier];
            const { tags, description, columns, attribute, constraint } = spec, rest = tslib_1.__rest(spec, ["tags", "description", "columns", "attribute", "constraint"]);
            if (Object.keys(rest).length > 0) {
                console.warn(`WARNING: makeJSONPgSmartTagsPlugin identifier spec only supports 'tags', 'description', 'attribute' and 'constraint' currently, you have also set '${Object.keys(rest).join("', '")}' at 'config.${kind}.${identifier}'`);
            }
            rules.push({
                kind,
                match: identifier,
                tags,
                description,
            });
            if (columns) {
                // This was in graphile-utils 4.0.0 but was deprecated in 4.0.1 for consistency reasons.
                process(kind, identifier, graphile_build_pg_1.PgEntityKind.ATTRIBUTE, columns, "columns", true);
            }
            if (attribute) {
                process(kind, identifier, graphile_build_pg_1.PgEntityKind.ATTRIBUTE, attribute, "attribute");
            }
            if (constraint) {
                process(kind, identifier, graphile_build_pg_1.PgEntityKind.CONSTRAINT, constraint, "constraint");
            }
        }
    }
    return rules;
}
function makeJSONPgSmartTagsPlugin(json, subscribeToJSONUpdatesCallback) {
    // Get rules from JSON
    let rules = pgSmartTagRulesFromJSON(json);
    // Wrap listener callback with JSON conversion
    const subscribeToUpdatesCallback = subscribeToJSONUpdatesCallback
        ? cb => {
            if (!cb) {
                return subscribeToJSONUpdatesCallback(cb);
            }
            else {
                return subscribeToJSONUpdatesCallback(json => {
                    try {
                        rules = pgSmartTagRulesFromJSON(json);
                        return cb(rules);
                    }
                    catch (e) {
                        console.error(e);
                    }
                });
            }
        }
        : null;
    return makePgSmartTagsPlugin(rules, subscribeToUpdatesCallback);
}
exports.makeJSONPgSmartTagsPlugin = makeJSONPgSmartTagsPlugin;
//# sourceMappingURL=makePgSmartTagsPlugin.js.map