"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fieldHelpers_1 = require("./fieldHelpers");
function makeWrapResolversPlugin(rulesOrGeneratorOrFilter, rule) {
    if (rule && typeof rule !== "function") {
        throw new Error("Invalid call signature for makeWrapResolversPlugin, expected second argument to be a function");
    }
    return (builder, options) => {
        // Disambiguate first argument
        const rulesOrGenerator = rule ? null : rulesOrGeneratorOrFilter;
        const filter = rule
            ? rulesOrGeneratorOrFilter
            : null;
        const rules = typeof rulesOrGenerator === "function"
            ? rulesOrGenerator(options)
            : rulesOrGenerator;
        builder.hook("GraphQLObjectType:fields:field", (field, build, context) => {
            const { Self, scope: { fieldName }, } = context;
            let resolveWrapperOrSpec;
            if (filter) {
                const filterResult = filter(context, build, field, options);
                if (!filterResult) {
                    if (filterResult !== null) {
                        // eslint-disable-next-line no-console
                        console.error(`Filter should return either a truthy value, or 'null', instead received: '${filterResult}'`);
                    }
                    return field;
                }
                resolveWrapperOrSpec = rule(filterResult);
            }
            else if (rules) {
                const typeRules = rules[Self.name];
                if (!typeRules) {
                    return field;
                }
                resolveWrapperOrSpec = typeRules[fieldName];
            }
            else {
                // Should not happen
                throw new Error("Bad call signature for function makeWrapResolversPlugin");
            }
            if (!resolveWrapperOrSpec) {
                return field;
            }
            const resolveWrapper = typeof resolveWrapperOrSpec === "function"
                ? resolveWrapperOrSpec
                : resolveWrapperOrSpec.resolve;
            const resolveWrapperRequirements = typeof resolveWrapperOrSpec === "function"
                ? undefined
                : resolveWrapperOrSpec.requires;
            if (resolveWrapperRequirements) {
                // Perform requirements
                if (resolveWrapperRequirements.childColumns) {
                    resolveWrapperRequirements.childColumns.forEach(({ column, alias }) => {
                        fieldHelpers_1.requireChildColumn(build, context, column, alias);
                    });
                }
                if (resolveWrapperRequirements.siblingColumns) {
                    resolveWrapperRequirements.siblingColumns.forEach(({ column, alias }) => {
                        fieldHelpers_1.requireSiblingColumn(build, context, column, alias);
                    });
                }
            }
            if (!resolveWrapper) {
                return field;
            }
            const { resolve: oldResolve = (obj) => obj[fieldName], } = field;
            return Object.assign(Object.assign({}, field), { async resolve(...resolveParams) {
                    const smartResolve = (...overrideParams) => oldResolve(
                    // @ts-ignore We're calling it dynamically, allowing the parent to override args.
                    ...overrideParams.concat(resolveParams.slice(overrideParams.length)));
                    const [source, args, graphqlContext, resolveInfo] = resolveParams;
                    const resolveInfoWithHelpers = Object.assign(Object.assign({}, resolveInfo), { graphile: fieldHelpers_1.makeFieldHelpers(build, context, graphqlContext, resolveInfo) });
                    return resolveWrapper(smartResolve, source, args, graphqlContext, resolveInfoWithHelpers);
                } });
        });
    };
}
exports.default = makeWrapResolversPlugin;
//# sourceMappingURL=makeWrapResolversPlugin.js.map