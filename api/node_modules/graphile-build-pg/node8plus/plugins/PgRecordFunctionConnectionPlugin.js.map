{"version":3,"sources":["../../src/plugins/PgRecordFunctionConnectionPlugin.js"],"names":["base64","str","Buffer","from","String","toString","PgRecordFunctionConnectionPlugin","builder","pgForbidSetofFunctionsToReturnNull","hook","_","build","newWithHooks","getSafeAliasFromResolveInfo","pgIntrospectionResultsByKind","introspectionResultsByKind","getTypeByName","graphql","GraphQLObjectType","GraphQLNonNull","GraphQLList","inflection","pgOmit","omit","describePgEntity","sqlCommentByAddingTags","pgField","nullableIf","condition","Type","Cursor","procedure","forEach","proc","returnsSet","namespace","returnTypeId","NodeType","recordFunctionReturnType","Error","name","EdgeType","recordFunctionEdge","description","wrapDescription","fields","fieldWithHooks","cursor","addDataGenerator","usesCursor","type","resolve","data","JSON","stringify","__cursor","isCursorField","node","_args","_context","resolveInfo","safeAlias","__origin","isEdgeType","nodeType","pgIntrospection","recordFunctionConnection","nodes","map","entry","edges","hoistCursor","isConnectionType","isPgRowConnectionType","edgeType"],"mappings":"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","sourcesContent":["// @flow\nimport type { Plugin } from \"graphile-build\";\n\nconst base64 = str => Buffer.from(String(str)).toString(\"base64\");\n\nexport default (function PgRecordFunctionConnectionPlugin(\n  builder,\n  { pgForbidSetofFunctionsToReturnNull = false }\n) {\n  builder.hook(\n    \"init\",\n    (_, build) => {\n      const {\n        newWithHooks,\n        getSafeAliasFromResolveInfo,\n        pgIntrospectionResultsByKind: introspectionResultsByKind,\n        getTypeByName,\n        graphql: { GraphQLObjectType, GraphQLNonNull, GraphQLList },\n        inflection,\n        pgOmit: omit,\n        describePgEntity,\n        sqlCommentByAddingTags,\n        pgField,\n      } = build;\n\n      const nullableIf = (condition, Type) =>\n        condition ? Type : new GraphQLNonNull(Type);\n      const Cursor = getTypeByName(\"Cursor\");\n\n      introspectionResultsByKind.procedure.forEach(proc => {\n        // PERFORMANCE: These used to be .filter(...) calls\n        if (!proc.returnsSet) return;\n        if (!proc.namespace) return;\n        if (omit(proc, \"execute\")) return;\n\n        if (proc.returnTypeId !== \"2249\") {\n          // Does not return a record type; defer handling to\n          // PgTablesPlugin and PgScalarFunctionConnectionPlugin\n          return;\n        }\n        // TODO: PG10 doesn't support the equivalent of pg_attribute.atttypemod\n        // on function arguments and return types, however maybe a later\n        // version of PG will?\n        const NodeType = getTypeByName(\n          inflection.recordFunctionReturnType(proc)\n        );\n        if (!NodeType) {\n          throw new Error(\n            `Do not have a node type '${inflection.recordFunctionReturnType(\n              proc\n            )}' for '${proc.name}' so cannot create connection type`\n          );\n        }\n        const EdgeType = newWithHooks(\n          GraphQLObjectType,\n          {\n            name: inflection.recordFunctionEdge(proc),\n            description: build.wrapDescription(\n              `A \\`${NodeType.name}\\` edge in the connection.`,\n              \"type\"\n            ),\n            fields: ({ fieldWithHooks }) => {\n              return {\n                cursor: fieldWithHooks(\n                  \"cursor\",\n                  ({ addDataGenerator }) => {\n                    addDataGenerator(() => ({\n                      usesCursor: [true],\n                    }));\n                    return {\n                      description: build.wrapDescription(\n                        \"A cursor for use in pagination.\",\n                        \"field\"\n                      ),\n                      type: Cursor,\n                      resolve(data) {\n                        return base64(JSON.stringify(data.__cursor));\n                      },\n                    };\n                  },\n                  {\n                    isCursorField: true,\n                  }\n                ),\n                node: pgField(\n                  build,\n                  fieldWithHooks,\n                  \"node\",\n                  {\n                    description: build.wrapDescription(\n                      `The \\`${NodeType.name}\\` at the end of the edge.`,\n                      \"field\"\n                    ),\n                    type: nullableIf(\n                      !pgForbidSetofFunctionsToReturnNull,\n                      NodeType\n                    ),\n                    resolve(data, _args, _context, resolveInfo) {\n                      const safeAlias = getSafeAliasFromResolveInfo(\n                        resolveInfo\n                      );\n                      return data[safeAlias];\n                    },\n                  },\n                  {},\n                  false\n                ),\n              };\n            },\n          },\n          {\n            __origin: `Adding function result edge type for ${describePgEntity(\n              proc\n            )}. You can rename the function's GraphQL field (and its dependent types) via a 'Smart Comment':\\n\\n  ${sqlCommentByAddingTags(\n              proc,\n              {\n                name: \"newNameHere\",\n              }\n            )}`,\n            isEdgeType: true,\n            nodeType: NodeType,\n            pgIntrospection: proc,\n          }\n        );\n\n        /*const ConnectionType = */\n        newWithHooks(\n          GraphQLObjectType,\n          {\n            name: inflection.recordFunctionConnection(proc),\n            description: build.wrapDescription(\n              `A connection to a list of \\`${NodeType.name}\\` values.`,\n              \"type\"\n            ),\n            fields: ({ fieldWithHooks }) => {\n              return {\n                nodes: pgField(build, fieldWithHooks, \"nodes\", {\n                  description: build.wrapDescription(\n                    `A list of \\`${NodeType.name}\\` objects.`,\n                    \"field\"\n                  ),\n                  type: new GraphQLNonNull(\n                    new GraphQLList(\n                      nullableIf(!pgForbidSetofFunctionsToReturnNull, NodeType)\n                    )\n                  ),\n                  resolve(data, _args, _context, resolveInfo) {\n                    const safeAlias = getSafeAliasFromResolveInfo(resolveInfo);\n                    return data.data.map(entry => entry[safeAlias]);\n                  },\n                }),\n                edges: pgField(\n                  build,\n                  fieldWithHooks,\n                  \"edges\",\n                  {\n                    description: build.wrapDescription(\n                      `A list of edges which contains the \\`${NodeType.name}\\` and cursor to aid in pagination.`,\n                      \"field\"\n                    ),\n                    type: new GraphQLNonNull(\n                      new GraphQLList(new GraphQLNonNull(EdgeType))\n                    ),\n                    resolve(data, _args, _context, resolveInfo) {\n                      const safeAlias = getSafeAliasFromResolveInfo(\n                        resolveInfo\n                      );\n                      return data.data.map(entry => ({\n                        __cursor: entry.__cursor,\n                        ...entry[safeAlias],\n                      }));\n                    },\n                  },\n                  {},\n                  false,\n                  {\n                    hoistCursor: true,\n                  }\n                ),\n              };\n            },\n          },\n          {\n            __origin: `Adding function connection type for ${describePgEntity(\n              proc\n            )}. You can rename the function's GraphQL field (and its dependent types) via a 'Smart Comment':\\n\\n  ${sqlCommentByAddingTags(\n              proc,\n              {\n                name: \"newNameHere\",\n              }\n            )}`,\n            isConnectionType: true,\n            isPgRowConnectionType: true,\n            edgeType: EdgeType,\n            nodeType: NodeType,\n            pgIntrospection: proc,\n          }\n        );\n      });\n      return _;\n    },\n    [\"PgRecordFunctionConnection\"]\n  );\n}: Plugin);\n"],"file":"PgRecordFunctionConnectionPlugin.js"}