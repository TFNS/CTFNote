{"version":3,"sources":["../../src/plugins/PgColumnsPlugin.js"],"names":["nullableIf","GraphQLNonNull","condition","Type","PgColumnsPlugin","builder","hook","build","pgSql","sql","pgTweakFragmentForTypeAndModifier","pgQueryFromResolveData","queryFromResolveData","getSelectValueForFieldAndTypeAndModifier","ReturnType","fieldScope","parsedResolveInfoFragment","sqlFullName","type","typeModifier","getDataFromParsedResolveInfoFragment","isPgArray","ident","identifier","Symbol","fragment","arrayItemType","resolveData","isDefinitelyNotATable","class","isSelectable","jsonBuildObject","onlyJsonField","addNullCase","addNotDistinctFromNullCase","extend","pgGetSelectValueForFieldAndTypeAndModifier","fields","context","pgGetGqlTypeByTypeIdAndModifier","pg2gqlForType","graphql","GraphQLString","pgColumnFilter","inflection","pgOmit","omit","describePgEntity","sqlCommentByAddingTags","scope","isPgRowType","isPgCompoundType","pgIntrospection","table","fieldWithHooks","kind","attributes","reduce","memo","attr","fieldName","column","Error","namespaceName","name","fieldContext","sqlColumn","addDataGenerator","typeId","pgQuery","queryBuilder","select","getTableAlias","convertFromPg","description","isNotNull","domainIsNotNull","tags","notNull","resolve","data","_args","_context","_resolveInfo","pgFieldIntrospection","pgGetGqlInputTypeByTypeIdAndModifier","isPgPatch","isPgBaseInput","pgAddSubfield","action","identity","domainHasDefault","hasDefault"],"mappings":"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","sourcesContent":["// @flow\nimport type { Plugin } from \"graphile-build\";\n\nconst nullableIf = (GraphQLNonNull, condition, Type) =>\n  condition ? Type : new GraphQLNonNull(Type);\n\nexport default (function PgColumnsPlugin(builder) {\n  builder.hook(\n    \"build\",\n    build => {\n      const {\n        pgSql: sql,\n        pgTweakFragmentForTypeAndModifier,\n        pgQueryFromResolveData: queryFromResolveData,\n      } = build;\n      const getSelectValueForFieldAndTypeAndModifier = (\n        ReturnType,\n        fieldScope,\n        parsedResolveInfoFragment,\n        sqlFullName,\n        type,\n        typeModifier\n      ) => {\n        const { getDataFromParsedResolveInfoFragment } = fieldScope;\n        if (type.isPgArray) {\n          const ident = sql.identifier(Symbol());\n          return sql.fragment`(\\\ncase\nwhen ${sqlFullName} is null then null\nwhen coalesce(array_length(${sqlFullName}, 1), 0) = 0 then '[]'::json\nelse (\n  select json_agg(${getSelectValueForFieldAndTypeAndModifier(\n    ReturnType,\n    fieldScope,\n    parsedResolveInfoFragment,\n    ident,\n    type.arrayItemType,\n    typeModifier\n  )}) from unnest(${sqlFullName}) as ${ident}\n)\nend\n)`;\n        } else {\n          const resolveData = getDataFromParsedResolveInfoFragment(\n            parsedResolveInfoFragment,\n            ReturnType\n          );\n          if (type.type === \"c\") {\n            const isDefinitelyNotATable =\n              type.class && !type.class.isSelectable;\n            const jsonBuildObject = queryFromResolveData(\n              sql.identifier(Symbol()), // Ignore!\n              sqlFullName,\n              resolveData,\n              {\n                onlyJsonField: true,\n                addNullCase: !isDefinitelyNotATable,\n                addNotDistinctFromNullCase: isDefinitelyNotATable,\n              }\n            );\n            return jsonBuildObject;\n          } else {\n            return pgTweakFragmentForTypeAndModifier(\n              sqlFullName,\n              type,\n              typeModifier,\n              resolveData\n            );\n          }\n        }\n      };\n      return build.extend(build, {\n        pgGetSelectValueForFieldAndTypeAndModifier: getSelectValueForFieldAndTypeAndModifier,\n      });\n    },\n    [\"PgColumns\"],\n    [],\n    [\"PgTypes\"]\n  );\n\n  builder.hook(\n    \"GraphQLObjectType:fields\",\n    (fields, build, context) => {\n      const {\n        extend,\n        pgGetGqlTypeByTypeIdAndModifier,\n        pgSql: sql,\n        pg2gqlForType,\n        graphql: { GraphQLString, GraphQLNonNull },\n        pgColumnFilter,\n        inflection,\n        pgOmit: omit,\n        pgGetSelectValueForFieldAndTypeAndModifier: getSelectValueForFieldAndTypeAndModifier,\n        describePgEntity,\n        sqlCommentByAddingTags,\n      } = build;\n      const {\n        scope: { isPgRowType, isPgCompoundType, pgIntrospection: table },\n        fieldWithHooks,\n      } = context;\n\n      if (\n        !(isPgRowType || isPgCompoundType) ||\n        !table ||\n        table.kind !== \"class\"\n      ) {\n        return fields;\n      }\n\n      return extend(\n        fields,\n        table.attributes.reduce((memo, attr) => {\n          // PERFORMANCE: These used to be .filter(...) calls\n          if (!pgColumnFilter(attr, build, context)) return memo;\n          if (omit(attr, \"read\")) return memo;\n\n          const fieldName = inflection.column(attr);\n          if (memo[fieldName]) {\n            throw new Error(\n              `Two columns produce the same GraphQL field name '${fieldName}' on class '${table.namespaceName}.${table.name}'; one of them is '${attr.name}'`\n            );\n          }\n          memo = extend(\n            memo,\n            {\n              [fieldName]: fieldWithHooks(\n                fieldName,\n                fieldContext => {\n                  const { type, typeModifier } = attr;\n                  const sqlColumn = sql.identifier(attr.name);\n                  const { addDataGenerator } = fieldContext;\n                  const ReturnType =\n                    pgGetGqlTypeByTypeIdAndModifier(\n                      attr.typeId,\n                      attr.typeModifier\n                    ) || GraphQLString;\n                  addDataGenerator(parsedResolveInfoFragment => {\n                    return {\n                      pgQuery: queryBuilder => {\n                        queryBuilder.select(\n                          getSelectValueForFieldAndTypeAndModifier(\n                            ReturnType,\n                            fieldContext,\n                            parsedResolveInfoFragment,\n                            sql.fragment`(${queryBuilder.getTableAlias()}.${sqlColumn})`, // The brackets are necessary to stop the parser getting confused, ref: https://www.postgresql.org/docs/9.6/static/rowtypes.html#ROWTYPES-ACCESSING\n                            type,\n                            typeModifier\n                          ),\n                          fieldName\n                        );\n                      },\n                    };\n                  });\n                  const convertFromPg = pg2gqlForType(type);\n                  return {\n                    description: attr.description,\n                    type: nullableIf(\n                      GraphQLNonNull,\n                      !attr.isNotNull &&\n                        !attr.type.domainIsNotNull &&\n                        !attr.tags.notNull,\n                      ReturnType\n                    ),\n                    resolve: (data, _args, _context, _resolveInfo) => {\n                      return convertFromPg(data[fieldName]);\n                    },\n                  };\n                },\n                { pgFieldIntrospection: attr }\n              ),\n            },\n            `Adding field for ${describePgEntity(\n              attr\n            )}. You can rename this field with a 'Smart Comment':\\n\\n  ${sqlCommentByAddingTags(\n              attr,\n              {\n                name: \"newNameHere\",\n              }\n            )}`\n          );\n          return memo;\n        }, {}),\n        `Adding columns to '${describePgEntity(table)}'`\n      );\n    },\n    [\"PgColumns\"]\n  );\n  builder.hook(\n    \"GraphQLInputObjectType:fields\",\n    (fields, build, context) => {\n      const {\n        extend,\n        pgGetGqlInputTypeByTypeIdAndModifier,\n        graphql: { GraphQLString, GraphQLNonNull },\n        pgColumnFilter,\n        inflection,\n        pgOmit: omit,\n        describePgEntity,\n        sqlCommentByAddingTags,\n      } = build;\n      const {\n        scope: {\n          isPgRowType,\n          isPgCompoundType,\n          isPgPatch,\n          isPgBaseInput,\n          pgIntrospection: table,\n          pgAddSubfield,\n        },\n        fieldWithHooks,\n      } = context;\n      if (\n        !(isPgRowType || isPgCompoundType) ||\n        !table ||\n        table.kind !== \"class\"\n      ) {\n        return fields;\n      }\n      return extend(\n        fields,\n        table.attributes.reduce((memo, attr) => {\n          // PERFORMANCE: These used to be .filter(...) calls\n          if (!pgColumnFilter(attr, build, context)) return memo;\n          const action = isPgBaseInput\n            ? \"base\"\n            : isPgPatch\n            ? \"update\"\n            : \"create\";\n          if (omit(attr, action)) return memo;\n          if (attr.identity === \"a\") return memo;\n\n          const fieldName = inflection.column(attr);\n          if (memo[fieldName]) {\n            throw new Error(\n              `Two columns produce the same GraphQL field name '${fieldName}' on input class '${table.namespaceName}.${table.name}'; one of them is '${attr.name}'`\n            );\n          }\n          memo = extend(\n            memo,\n            {\n              [fieldName]: fieldWithHooks(\n                fieldName,\n                pgAddSubfield(\n                  fieldName,\n                  attr.name,\n                  attr.type,\n                  {\n                    description: attr.description,\n                    type: nullableIf(\n                      GraphQLNonNull,\n                      isPgBaseInput ||\n                        isPgPatch ||\n                        (!attr.isNotNull &&\n                          (!attr.type.domainIsNotNull ||\n                            attr.type.domainHasDefault) &&\n                          !attr.tags.notNull) ||\n                        attr.hasDefault ||\n                        attr.identity === \"d\",\n                      pgGetGqlInputTypeByTypeIdAndModifier(\n                        attr.typeId,\n                        attr.typeModifier\n                      ) || GraphQLString\n                    ),\n                  },\n                  attr.typeModifier\n                ),\n                { pgFieldIntrospection: attr }\n              ),\n            },\n            `Adding input object field for ${describePgEntity(\n              attr\n            )}. You can rename this field with a 'Smart Comment':\\n\\n  ${sqlCommentByAddingTags(\n              attr,\n              {\n                name: \"newNameHere\",\n              }\n            )}`\n          );\n          return memo;\n        }, {}),\n        `Adding columns to input object for ${describePgEntity(table)}`\n      );\n    },\n    [\"PgColumns\"]\n  );\n}: Plugin);\n"],"file":"PgColumnsPlugin.js"}