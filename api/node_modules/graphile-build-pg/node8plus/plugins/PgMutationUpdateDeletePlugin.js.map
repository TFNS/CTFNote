{"version":3,"sources":["../../src/plugins/PgMutationUpdateDeletePlugin.js"],"names":["debug","PgMutationUpdateDeletePlugin","builder","pgDisableDefaultMutations","hook","fields","build","context","newWithHooks","getNodeIdForTypeAndIdentifiers","getTypeAndIdentifiersFromNodeId","nodeIdFieldName","fieldDataGeneratorsByType","extend","parseResolveInfo","getTypeByName","gql2pg","pgGetGqlTypeByTypeIdAndModifier","pgGetGqlInputTypeByTypeIdAndModifier","pgIntrospectionResultsByKind","introspectionResultsByKind","pgSql","sql","graphql","GraphQLNonNull","GraphQLInputObjectType","GraphQLString","GraphQLObjectType","GraphQLID","pgColumnFilter","inflection","pgQueryFromResolveData","queryFromResolveData","pgOmit","omit","pgViaTemporaryTable","viaTemporaryTable","describePgEntity","sqlCommentByAddingTags","pgField","scope","isRootMutation","fieldWithHooks","reduce","outerMemo","mode","class","memo","table","namespace","canUpdate","isUpdatable","attributes","find","attr","canDelete","isDeletable","TableType","type","id","commonCodeRenameMe","pgClient","resolveInfo","getDataFromParsedResolveInfoFragment","PayloadType","args","condition","resolveContext","input","parsedResolveInfoFragment","resolveData","sqlTypeIdentifier","identifier","name","sqlMutationQuery","sqlColumns","sqlValues","inputData","patchField","tableFieldName","forEach","fieldName","column","val","push","typeModifier","length","query","join","map","col","i","fragment","modifiedRowAlias","Symbol","rootValue","row","rows","e","Error","pluralize","_singularizedTableName","clientMutationId","data","uniqueConstraints","constraints","filter","con","Table","tableTypeName","TablePatch","patchType","description","wrapDescription","tableName","deletedNodeIdFieldName","deletedNodeId","Object","assign","addDataGenerator","fieldDataGeneratorsByTableType","get","gens","gen","resolve","__identifiers","isPgMutationPayloadDeletedNodeIdField","__origin","isMutationPayload","isPgUpdatePayloadType","isPgDeletePayloadType","pgIntrospection","primaryKeyConstraint","primaryKeys","keyAttributes","InputType","isPgUpdateInputType","isPgUpdateNodeInputType","isPgDeleteInputType","isPgDeleteNodeInputType","pgInflection","isMutationInput","parent","nodeId","Type","identifiers","key","idx","isPgNodeMutation","pgFieldIntrospection","constraint","keys","every","_","some","typeId","isPgUpdateByKeysInputType","isPgDeleteByKeysInputType","pgKeys","pgFieldConstraint"],"mappings":"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","sourcesContent":["// @flow\nimport type { Plugin } from \"graphile-build\";\nimport debugFactory from \"debug\";\n\nconst debug = debugFactory(\"graphile-build-pg\");\n\nexport default (async function PgMutationUpdateDeletePlugin(\n  builder,\n  { pgDisableDefaultMutations }\n) {\n  if (pgDisableDefaultMutations) {\n    return;\n  }\n\n  builder.hook(\n    \"GraphQLObjectType:fields\",\n    (fields, build, context) => {\n      const {\n        newWithHooks,\n        getNodeIdForTypeAndIdentifiers,\n        getTypeAndIdentifiersFromNodeId,\n        nodeIdFieldName,\n        fieldDataGeneratorsByType,\n        extend,\n        parseResolveInfo,\n        getTypeByName,\n        gql2pg,\n        pgGetGqlTypeByTypeIdAndModifier,\n        pgGetGqlInputTypeByTypeIdAndModifier,\n        pgIntrospectionResultsByKind: introspectionResultsByKind,\n        pgSql: sql,\n        graphql: {\n          GraphQLNonNull,\n          GraphQLInputObjectType,\n          GraphQLString,\n          GraphQLObjectType,\n          GraphQLID,\n        },\n        pgColumnFilter,\n        inflection,\n        pgQueryFromResolveData: queryFromResolveData,\n        pgOmit: omit,\n        pgViaTemporaryTable: viaTemporaryTable,\n        describePgEntity,\n        sqlCommentByAddingTags,\n        pgField,\n      } = build;\n      const {\n        scope: { isRootMutation },\n        fieldWithHooks,\n      } = context;\n\n      if (!isRootMutation) {\n        return fields;\n      }\n\n      return extend(\n        fields,\n        [\"update\", \"delete\"].reduce(\n          (outerMemo, mode) =>\n            introspectionResultsByKind.class.reduce((memo, table) => {\n              // PERFORMANCE: These used to be .filter(...) calls\n              if (!table.namespace) return memo;\n              const canUpdate =\n                mode === \"update\" &&\n                table.isUpdatable &&\n                !omit(table, \"update\") &&\n                // Check at least one attribute is updatable\n                table.attributes.find(attr => !omit(attr, \"update\"));\n              const canDelete =\n                mode === \"delete\" &&\n                table.isDeletable &&\n                !omit(table, \"delete\");\n              if (!canUpdate && !canDelete) return memo;\n\n              const TableType = pgGetGqlTypeByTypeIdAndModifier(\n                table.type.id,\n                null\n              );\n              if (!TableType) {\n                return memo;\n              }\n              async function commonCodeRenameMe(\n                pgClient,\n                resolveInfo,\n                getDataFromParsedResolveInfoFragment,\n                PayloadType,\n                args,\n                condition,\n                context,\n                resolveContext\n              ) {\n                const { input } = args;\n                const parsedResolveInfoFragment = parseResolveInfo(resolveInfo);\n                parsedResolveInfoFragment.args = args; // Allow overriding via makeWrapResolversPlugin\n                const resolveData = getDataFromParsedResolveInfoFragment(\n                  parsedResolveInfoFragment,\n                  PayloadType\n                );\n\n                const sqlTypeIdentifier = sql.identifier(\n                  table.namespace.name,\n                  table.name\n                );\n\n                let sqlMutationQuery;\n                if (mode === \"update\") {\n                  const sqlColumns = [];\n                  const sqlValues = [];\n                  const inputData =\n                    input[\n                      inflection.patchField(inflection.tableFieldName(table))\n                    ];\n                  table.attributes.forEach(attr => {\n                    // PERFORMANCE: These used to be .filter(...) calls\n                    if (!pgColumnFilter(attr, build, context)) return;\n                    if (omit(attr, \"update\")) return;\n\n                    const fieldName = inflection.column(attr);\n                    if (\n                      fieldName in inputData /* Because we care about null! */\n                    ) {\n                      const val = inputData[fieldName];\n                      sqlColumns.push(sql.identifier(attr.name));\n                      sqlValues.push(gql2pg(val, attr.type, attr.typeModifier));\n                    }\n                  });\n                  if (sqlColumns.length === 0) {\n                    return null;\n                  }\n                  sqlMutationQuery = sql.query`\\\nupdate ${sql.identifier(table.namespace.name, table.name)} set ${sql.join(\n                    sqlColumns.map(\n                      (col, i) => sql.fragment`${col} = ${sqlValues[i]}`\n                    ),\n                    \", \"\n                  )}\nwhere ${condition}\nreturning *`;\n                } else {\n                  sqlMutationQuery = sql.query`\\\ndelete from ${sql.identifier(table.namespace.name, table.name)}\nwhere ${condition}\nreturning *`;\n                }\n\n                const modifiedRowAlias = sql.identifier(Symbol());\n                const query = queryFromResolveData(\n                  modifiedRowAlias,\n                  modifiedRowAlias,\n                  resolveData,\n                  {},\n                  null,\n                  resolveContext,\n                  resolveInfo.rootValue\n                );\n                let row;\n                try {\n                  await pgClient.query(\"SAVEPOINT graphql_mutation\");\n                  const rows = await viaTemporaryTable(\n                    pgClient,\n                    sqlTypeIdentifier,\n                    sqlMutationQuery,\n                    modifiedRowAlias,\n                    query\n                  );\n                  row = rows[0];\n                  await pgClient.query(\"RELEASE SAVEPOINT graphql_mutation\");\n                } catch (e) {\n                  await pgClient.query(\n                    \"ROLLBACK TO SAVEPOINT graphql_mutation\"\n                  );\n                  throw e;\n                }\n                if (!row) {\n                  throw new Error(\n                    `No values were ${mode}d in collection '${inflection.pluralize(\n                      inflection._singularizedTableName(table)\n                    )}' because no values you can ${mode} were found matching these criteria.`\n                  );\n                }\n                return {\n                  clientMutationId: input.clientMutationId,\n                  data: row,\n                };\n              }\n              if (TableType) {\n                const uniqueConstraints = table.constraints.filter(\n                  con => con.type === \"u\" || con.type === \"p\"\n                );\n                const Table = pgGetGqlTypeByTypeIdAndModifier(\n                  table.type.id,\n                  null\n                );\n                const tableTypeName = Table.name;\n                const TablePatch = getTypeByName(\n                  inflection.patchType(Table.name)\n                );\n                const PayloadType = newWithHooks(\n                  GraphQLObjectType,\n                  {\n                    name: inflection[\n                      mode === \"delete\"\n                        ? \"deletePayloadType\"\n                        : \"updatePayloadType\"\n                    ](table),\n                    description: build.wrapDescription(\n                      `The output of our ${mode} \\`${tableTypeName}\\` mutation.`,\n                      \"type\"\n                    ),\n                    fields: ({ fieldWithHooks }) => {\n                      const tableName = inflection.tableFieldName(table);\n                      // This should really be `-node-id` but for compatibility with PostGraphQL v3 we haven't made that change.\n                      const deletedNodeIdFieldName = inflection.deletedNodeId(\n                        table\n                      );\n                      return Object.assign(\n                        {\n                          clientMutationId: {\n                            description: build.wrapDescription(\n                              \"The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations.\",\n                              \"field\"\n                            ),\n                            type: GraphQLString,\n                          },\n                          [tableName]: pgField(\n                            build,\n                            fieldWithHooks,\n                            tableName,\n                            {\n                              description: build.wrapDescription(\n                                `The \\`${tableTypeName}\\` that was ${mode}d by this mutation.`,\n                                \"field\"\n                              ),\n                              type: Table,\n                            },\n                            {},\n                            false\n                          ),\n                        },\n                        mode === \"delete\"\n                          ? {\n                              [deletedNodeIdFieldName]: fieldWithHooks(\n                                deletedNodeIdFieldName,\n                                ({ addDataGenerator }) => {\n                                  const fieldDataGeneratorsByTableType = fieldDataGeneratorsByType.get(\n                                    TableType\n                                  );\n\n                                  const gens =\n                                    fieldDataGeneratorsByTableType &&\n                                    fieldDataGeneratorsByTableType[\n                                      nodeIdFieldName\n                                    ];\n                                  if (gens) {\n                                    gens.forEach(gen => addDataGenerator(gen));\n                                  }\n                                  return {\n                                    type: GraphQLID,\n                                    resolve(data) {\n                                      return (\n                                        data.data.__identifiers &&\n                                        getNodeIdForTypeAndIdentifiers(\n                                          Table,\n                                          ...data.data.__identifiers\n                                        )\n                                      );\n                                    },\n                                  };\n                                },\n                                {\n                                  isPgMutationPayloadDeletedNodeIdField: true,\n                                }\n                              ),\n                            }\n                          : null\n                      );\n                    },\n                  },\n                  {\n                    __origin: `Adding table ${mode} mutation payload type for ${describePgEntity(\n                      table\n                    )}. You can rename the table's GraphQL type via a 'Smart Comment':\\n\\n  ${sqlCommentByAddingTags(\n                      table,\n                      {\n                        name: \"newNameHere\",\n                      }\n                    )}`,\n                    isMutationPayload: true,\n                    isPgUpdatePayloadType: mode === \"update\",\n                    isPgDeletePayloadType: mode === \"delete\",\n                    pgIntrospection: table,\n                  }\n                );\n\n                // NodeId\n                const primaryKeyConstraint = table.primaryKeyConstraint;\n                if (nodeIdFieldName && primaryKeyConstraint) {\n                  const primaryKeys =\n                    primaryKeyConstraint && primaryKeyConstraint.keyAttributes;\n                  const fieldName = inflection[\n                    mode === \"update\" ? \"updateNode\" : \"deleteNode\"\n                  ](table);\n                  const InputType = newWithHooks(\n                    GraphQLInputObjectType,\n                    {\n                      description: build.wrapDescription(\n                        `All input for the \\`${fieldName}\\` mutation.`,\n                        \"type\"\n                      ),\n                      name: inflection[\n                        mode === \"update\"\n                          ? \"updateNodeInputType\"\n                          : \"deleteNodeInputType\"\n                      ](table),\n                      fields: Object.assign(\n                        {\n                          clientMutationId: {\n                            description: build.wrapDescription(\n                              \"An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client.\",\n                              \"field\"\n                            ),\n                            type: GraphQLString,\n                          },\n                          [nodeIdFieldName]: {\n                            description: build.wrapDescription(\n                              `The globally unique \\`ID\\` which will identify a single \\`${tableTypeName}\\` to be ${mode}d.`,\n                              \"field\"\n                            ),\n                            type: new GraphQLNonNull(GraphQLID),\n                          },\n                        },\n                        mode === \"update\"\n                          ? {\n                              [inflection.patchField(\n                                inflection.tableFieldName(table)\n                              )]: {\n                                description: build.wrapDescription(\n                                  `An object where the defined keys will be set on the \\`${tableTypeName}\\` being ${mode}d.`,\n                                  \"field\"\n                                ),\n                                type: new GraphQLNonNull(TablePatch),\n                              },\n                            }\n                          : null\n                      ),\n                    },\n                    {\n                      __origin: `Adding table ${mode} (by node ID) mutation input type for ${describePgEntity(\n                        table\n                      )}. You can rename the table's GraphQL type via a 'Smart Comment':\\n\\n  ${sqlCommentByAddingTags(\n                        table,\n                        {\n                          name: \"newNameHere\",\n                        }\n                      )}`,\n                      isPgUpdateInputType: mode === \"update\",\n                      isPgUpdateNodeInputType: mode === \"update\",\n                      isPgDeleteInputType: mode === \"delete\",\n                      isPgDeleteNodeInputType: mode === \"delete\",\n                      pgInflection: table, // TODO:v5: remove - TYPO!\n                      pgIntrospection: table,\n                      isMutationInput: true,\n                    }\n                  );\n\n                  memo = extend(\n                    memo,\n                    {\n                      [fieldName]: fieldWithHooks(\n                        fieldName,\n                        context => {\n                          const {\n                            getDataFromParsedResolveInfoFragment,\n                          } = context;\n                          return {\n                            description: build.wrapDescription(\n                              mode === \"update\"\n                                ? `Updates a single \\`${tableTypeName}\\` using its globally unique id and a patch.`\n                                : `Deletes a single \\`${tableTypeName}\\` using its globally unique id.`,\n                              \"field\"\n                            ),\n                            type: PayloadType,\n                            args: {\n                              input: {\n                                type: new GraphQLNonNull(InputType),\n                              },\n                            },\n                            async resolve(\n                              parent,\n                              args,\n                              resolveContext,\n                              resolveInfo\n                            ) {\n                              const { input } = args;\n                              const { pgClient } = resolveContext;\n                              const nodeId = input[nodeIdFieldName];\n                              try {\n                                const {\n                                  Type,\n                                  identifiers,\n                                } = getTypeAndIdentifiersFromNodeId(nodeId);\n                                if (Type !== TableType) {\n                                  throw new Error(\"Mismatched type\");\n                                }\n                                if (identifiers.length !== primaryKeys.length) {\n                                  throw new Error(\"Invalid ID\");\n                                }\n\n                                return commonCodeRenameMe(\n                                  pgClient,\n                                  resolveInfo,\n                                  getDataFromParsedResolveInfoFragment,\n                                  PayloadType,\n                                  args,\n                                  sql.fragment`(${sql.join(\n                                    primaryKeys.map(\n                                      (key, idx) =>\n                                        sql.fragment`${sql.identifier(\n                                          key.name\n                                        )} = ${gql2pg(\n                                          identifiers[idx],\n                                          key.type,\n                                          key.typeModifier\n                                        )}`\n                                    ),\n                                    \") and (\"\n                                  )})`,\n                                  context,\n                                  resolveContext\n                                );\n                              } catch (e) {\n                                debug(e);\n                                return null;\n                              }\n                            },\n                          };\n                        },\n                        {\n                          isPgNodeMutation: true,\n                          pgFieldIntrospection: table,\n                          [mode === \"update\"\n                            ? \"isPgUpdateMutationField\"\n                            : \"isPgDeleteMutationField\"]: true,\n                        }\n                      ),\n                    },\n                    \"Adding ${mode} mutation for ${describePgEntity(table)}\"\n                  );\n                }\n\n                // Unique\n                uniqueConstraints.forEach(constraint => {\n                  if (omit(constraint, mode)) {\n                    return;\n                  }\n                  const keys = constraint.keyAttributes;\n                  if (!keys.every(_ => _)) {\n                    throw new Error(\n                      `Consistency error: could not find an attribute in the constraint when building the ${mode} mutation for ${describePgEntity(\n                        table\n                      )}!`\n                    );\n                  }\n                  if (keys.some(key => omit(key, \"read\"))) {\n                    return;\n                  }\n                  const fieldName = inflection[\n                    mode === \"update\" ? \"updateByKeys\" : \"deleteByKeys\"\n                  ](keys, table, constraint);\n                  const InputType = newWithHooks(\n                    GraphQLInputObjectType,\n                    {\n                      description: build.wrapDescription(\n                        `All input for the \\`${fieldName}\\` mutation.`,\n                        \"type\"\n                      ),\n                      name: inflection[\n                        mode === \"update\"\n                          ? \"updateByKeysInputType\"\n                          : \"deleteByKeysInputType\"\n                      ](keys, table, constraint),\n                      fields: Object.assign(\n                        {\n                          clientMutationId: {\n                            type: GraphQLString,\n                          },\n                        },\n                        mode === \"update\"\n                          ? {\n                              [inflection.patchField(\n                                inflection.tableFieldName(table)\n                              )]: {\n                                description: build.wrapDescription(\n                                  `An object where the defined keys will be set on the \\`${tableTypeName}\\` being ${mode}d.`,\n                                  \"field\"\n                                ),\n                                type: new GraphQLNonNull(TablePatch),\n                              },\n                            }\n                          : null,\n                        keys.reduce((memo, key) => {\n                          memo[inflection.column(key)] = {\n                            description: key.description,\n                            type: new GraphQLNonNull(\n                              pgGetGqlInputTypeByTypeIdAndModifier(\n                                key.typeId,\n                                key.typeModifier\n                              )\n                            ),\n                          };\n                          return memo;\n                        }, {})\n                      ),\n                    },\n                    {\n                      __origin: `Adding table ${mode} mutation input type for ${describePgEntity(\n                        constraint\n                      )}. You can rename the table's GraphQL type via a 'Smart Comment':\\n\\n  ${sqlCommentByAddingTags(\n                        table,\n                        {\n                          name: \"newNameHere\",\n                        }\n                      )}`,\n                      isPgUpdateInputType: mode === \"update\",\n                      isPgUpdateByKeysInputType: mode === \"update\",\n                      isPgDeleteInputType: mode === \"delete\",\n                      isPgDeleteByKeysInputType: mode === \"delete\",\n                      pgInflection: table, // TODO:v5: remove - TYPO!\n                      pgIntrospection: table,\n                      pgKeys: keys,\n                      isMutationInput: true,\n                    }\n                  );\n\n                  memo = extend(\n                    memo,\n                    {\n                      [fieldName]: fieldWithHooks(\n                        fieldName,\n                        context => {\n                          const {\n                            getDataFromParsedResolveInfoFragment,\n                          } = context;\n                          return {\n                            description: build.wrapDescription(\n                              mode === \"update\"\n                                ? `Updates a single \\`${tableTypeName}\\` using a unique key and a patch.`\n                                : `Deletes a single \\`${tableTypeName}\\` using a unique key.`,\n                              \"field\"\n                            ),\n                            type: PayloadType,\n                            args: {\n                              input: {\n                                type: new GraphQLNonNull(InputType),\n                              },\n                            },\n                            async resolve(\n                              parent,\n                              args,\n                              resolveContext,\n                              resolveInfo\n                            ) {\n                              const { input } = args;\n                              const { pgClient } = resolveContext;\n                              return commonCodeRenameMe(\n                                pgClient,\n                                resolveInfo,\n                                getDataFromParsedResolveInfoFragment,\n                                PayloadType,\n                                args,\n                                sql.fragment`(${sql.join(\n                                  keys.map(\n                                    key =>\n                                      sql.fragment`${sql.identifier(\n                                        key.name\n                                      )} = ${gql2pg(\n                                        input[inflection.column(key)],\n                                        key.type,\n                                        key.typeModifier\n                                      )}`\n                                  ),\n                                  \") and (\"\n                                )})`,\n                                context,\n                                resolveContext\n                              );\n                            },\n                          };\n                        },\n                        {\n                          isPgNodeMutation: false,\n                          pgFieldIntrospection: table,\n                          pgFieldConstraint: constraint,\n                          [mode === \"update\"\n                            ? \"isPgUpdateMutationField\"\n                            : \"isPgDeleteMutationField\"]: true,\n                        }\n                      ),\n                    },\n                    `Adding ${mode} mutation for ${describePgEntity(\n                      constraint\n                    )}`\n                  );\n                });\n              }\n              return memo;\n            }, outerMemo),\n          {}\n        ),\n        `Adding default update/delete mutations to root Mutation type`\n      );\n    },\n    [\"PgMutationUpdateDelete\"]\n  );\n}: Plugin);\n"],"file":"PgMutationUpdateDeletePlugin.js"}