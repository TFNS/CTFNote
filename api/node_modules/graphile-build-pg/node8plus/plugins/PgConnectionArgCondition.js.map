{"version":3,"sources":["../../src/plugins/PgConnectionArgCondition.js"],"names":["PgConnectionArgCondition","builder","hook","_","build","newWithHooks","pgIntrospectionResultsByKind","introspectionResultsByKind","pgGetGqlInputTypeByTypeIdAndModifier","graphql","GraphQLInputObjectType","GraphQLString","pgColumnFilter","inflection","pgOmit","omit","describePgEntity","sqlCommentByAddingTags","class","forEach","table","isSelectable","namespace","tableTypeName","tableType","description","wrapDescription","name","conditionType","fields","context","fieldWithHooks","attributes","reduce","memo","attr","fieldName","column","extend","type","typeId","typeModifier","isPgConnectionConditionInputField","__origin","pgIntrospection","isPgCondition","args","pgSql","sql","gql2pg","getTypeByName","pgGetGqlTypeByTypeIdAndModifier","scope","isPgFieldConnection","isPgFieldSimpleCollection","pgFieldIntrospection","pgFieldIntrospectionTable","addArgDataGenerator","Self","shouldAddCondition","proc","kind","tags","filterable","TableType","id","TableConditionType","relevantAttributes","filter","connectionCondition","condition","pgQuery","queryBuilder","val","addLiveCondition","record","where","fragment","getTableAlias","identifier"],"mappings":"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","sourcesContent":["// @flow\nimport type { Plugin } from \"graphile-build\";\n\nexport default (function PgConnectionArgCondition(builder) {\n  builder.hook(\n    \"init\",\n    (_, build) => {\n      const {\n        newWithHooks,\n        pgIntrospectionResultsByKind: introspectionResultsByKind,\n        pgGetGqlInputTypeByTypeIdAndModifier,\n        graphql: { GraphQLInputObjectType, GraphQLString },\n        pgColumnFilter,\n        inflection,\n        pgOmit: omit,\n        describePgEntity,\n        sqlCommentByAddingTags,\n      } = build;\n      introspectionResultsByKind.class.forEach(table => {\n        // PERFORMANCE: These used to be .filter(...) calls\n        if (!table.isSelectable || omit(table, \"filter\")) return;\n        if (!table.namespace) return;\n\n        const tableTypeName = inflection.tableType(table);\n        /* const TableConditionType = */\n        newWithHooks(\n          GraphQLInputObjectType,\n          {\n            description: build.wrapDescription(\n              `A condition to be used against \\`${tableTypeName}\\` object types. All fields are tested for equality and combined with a logical ‘and.’`,\n              \"type\"\n            ),\n            name: inflection.conditionType(inflection.tableType(table)),\n            fields: context => {\n              const { fieldWithHooks } = context;\n              return table.attributes.reduce((memo, attr) => {\n                // PERFORMANCE: These used to be .filter(...) calls\n                if (!pgColumnFilter(attr, build, context)) return memo;\n                if (omit(attr, \"filter\")) return memo;\n\n                const fieldName = inflection.column(attr);\n                memo = build.extend(\n                  memo,\n                  {\n                    [fieldName]: fieldWithHooks(\n                      fieldName,\n                      {\n                        description: build.wrapDescription(\n                          `Checks for equality with the object’s \\`${fieldName}\\` field.`,\n                          \"field\"\n                        ),\n                        type:\n                          pgGetGqlInputTypeByTypeIdAndModifier(\n                            attr.typeId,\n                            attr.typeModifier\n                          ) || GraphQLString,\n                      },\n                      {\n                        isPgConnectionConditionInputField: true,\n                      }\n                    ),\n                  },\n                  `Adding condition argument for ${describePgEntity(attr)}`\n                );\n                return memo;\n              }, {});\n            },\n          },\n          {\n            __origin: `Adding condition type for ${describePgEntity(\n              table\n            )}. You can rename the table's GraphQL type via a 'Smart Comment':\\n\\n  ${sqlCommentByAddingTags(\n              table,\n              {\n                name: \"newNameHere\",\n              }\n            )}`,\n            pgIntrospection: table,\n            isPgCondition: true,\n          },\n          true // Conditions might all be filtered\n        );\n      });\n      return _;\n    },\n    [\"PgConnectionArgCondition\"],\n    [],\n    [\"PgTypes\"]\n  );\n\n  builder.hook(\n    \"GraphQLObjectType:fields:field:args\",\n    (args, build, context) => {\n      const {\n        pgSql: sql,\n        gql2pg,\n        extend,\n        getTypeByName,\n        pgGetGqlTypeByTypeIdAndModifier,\n        pgColumnFilter,\n        inflection,\n        pgOmit: omit,\n      } = build;\n      const {\n        scope: {\n          fieldName,\n          isPgFieldConnection,\n          isPgFieldSimpleCollection,\n          pgFieldIntrospection,\n          pgFieldIntrospectionTable,\n        },\n        addArgDataGenerator,\n        Self,\n      } = context;\n\n      const shouldAddCondition =\n        isPgFieldConnection || isPgFieldSimpleCollection;\n      if (!shouldAddCondition) return args;\n\n      const proc =\n        pgFieldIntrospection.kind === \"procedure\" ? pgFieldIntrospection : null;\n      const table =\n        pgFieldIntrospection.kind === \"class\"\n          ? pgFieldIntrospection\n          : proc\n          ? pgFieldIntrospectionTable\n          : null;\n      if (\n        !table ||\n        table.kind !== \"class\" ||\n        !table.namespace ||\n        omit(table, \"filter\")\n      ) {\n        return args;\n      }\n      if (proc) {\n        if (!proc.tags.filterable) {\n          return args;\n        }\n      }\n\n      const TableType = pgGetGqlTypeByTypeIdAndModifier(table.type.id, null);\n      const TableConditionType = getTypeByName(\n        inflection.conditionType(TableType.name)\n      );\n      if (!TableConditionType) {\n        return args;\n      }\n\n      const relevantAttributes = table.attributes.filter(\n        attr => pgColumnFilter(attr, build, context) && !omit(attr, \"filter\")\n      );\n\n      addArgDataGenerator(function connectionCondition({ condition }) {\n        return {\n          pgQuery: queryBuilder => {\n            if (condition != null) {\n              relevantAttributes.forEach(attr => {\n                const fieldName = inflection.column(attr);\n                const val = condition[fieldName];\n                if (val != null) {\n                  queryBuilder.addLiveCondition(() => record =>\n                    record[attr.name] === val\n                  );\n                  queryBuilder.where(\n                    sql.fragment`${queryBuilder.getTableAlias()}.${sql.identifier(\n                      attr.name\n                    )} = ${gql2pg(val, attr.type, attr.typeModifier)}`\n                  );\n                } else if (val === null) {\n                  queryBuilder.addLiveCondition(() => record =>\n                    record[attr.name] == null\n                  );\n                  queryBuilder.where(\n                    sql.fragment`${queryBuilder.getTableAlias()}.${sql.identifier(\n                      attr.name\n                    )} IS NULL`\n                  );\n                }\n              });\n            }\n          },\n        };\n      });\n\n      return extend(\n        args,\n        {\n          condition: {\n            description: build.wrapDescription(\n              \"A condition to be used in determining which values should be returned by the collection.\",\n              \"arg\"\n            ),\n            type: TableConditionType,\n          },\n        },\n        `Adding condition to connection field '${fieldName}' of '${Self.name}'`\n      );\n    },\n    [\"PgConnectionArgCondition\"]\n  );\n}: Plugin);\n"],"file":"PgConnectionArgCondition.js"}