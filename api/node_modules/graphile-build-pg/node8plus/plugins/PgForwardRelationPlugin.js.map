{"version":3,"sources":["../../src/plugins/PgForwardRelationPlugin.js"],"names":["debug","PgForwardRelationPlugin","builder","subscriptions","hook","fields","build","context","extend","getSafeAliasFromResolveInfo","getSafeAliasFromAlias","pgGetGqlTypeByTypeIdAndModifier","pgIntrospectionResultsByKind","introspectionResultsByKind","pgSql","sql","inflection","pgQueryFromResolveData","queryFromResolveData","pgOmit","omit","sqlCommentByAddingTags","describePgEntity","scope","isPgRowType","isPgCompositeType","isMutationPayload","pgIntrospection","pgIntrospectionTable","fieldWithHooks","Self","table","kind","namespace","returnTypeId","typeId","returnsSet","foreignKeyConstraints","constraints","filter","con","type","reduce","memo","constraint","gqlTableType","id","tableTypeName","name","classId","foreignTable","classById","foreignClassId","gqlForeignTableType","foreignTableTypeName","Error","foreignSchema","keys","keyAttributes","foreignKeys","foreignKeyAttributes","every","_","some","key","fieldName","singleRelationByKeys","getDataFromParsedResolveInfoFragment","addDataGenerator","parsedResolveInfoFragment","pgQuery","queryBuilder","select","resolveData","foreignTableAlias","identifier","Symbol","query","useAsterisk","asJson","innerQueryBuilder","parentQueryBuilder","primaryKeyConstraint","selectIdentifiers","forEach","i","where","fragment","getTableAlias","rootValue","alias","description","tags","forwardDescription","wrapDescription","resolve","rawData","_args","resolveContext","resolveInfo","data","safeAlias","record","liveRecord","__identifiers","pgFieldIntrospection","isPgForwardRelationField"],"mappings":"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","sourcesContent":["// @flow\nimport type { Plugin } from \"graphile-build\";\nimport debugFactory from \"debug\";\n\nconst debug = debugFactory(\"graphile-build-pg\");\n\nexport default (function PgForwardRelationPlugin(builder, { subscriptions }) {\n  builder.hook(\n    \"GraphQLObjectType:fields\",\n    (fields, build, context) => {\n      const {\n        extend,\n        getSafeAliasFromResolveInfo,\n        getSafeAliasFromAlias,\n        pgGetGqlTypeByTypeIdAndModifier,\n        pgIntrospectionResultsByKind: introspectionResultsByKind,\n        pgSql: sql,\n        inflection,\n        pgQueryFromResolveData: queryFromResolveData,\n        pgOmit: omit,\n        sqlCommentByAddingTags,\n        describePgEntity,\n      } = build;\n      const {\n        scope: {\n          isPgRowType,\n          isPgCompositeType,\n          isMutationPayload,\n          pgIntrospection,\n          pgIntrospectionTable,\n        },\n        fieldWithHooks,\n        Self,\n      } = context;\n\n      const table = pgIntrospectionTable || pgIntrospection;\n      if (\n        !(isPgRowType || isMutationPayload || isPgCompositeType) ||\n        !table ||\n        table.kind !== \"class\" ||\n        !table.namespace\n      ) {\n        return fields;\n      }\n      if (\n        isMutationPayload &&\n        pgIntrospection.kind === \"procedure\" &&\n        (pgIntrospection.returnTypeId !== table.typeId ||\n          pgIntrospection.returnsSet)\n      ) {\n        return fields;\n      }\n      // This is a relation in which we (table) are local, and there's a foreign table\n\n      const foreignKeyConstraints = table.constraints.filter(\n        con => con.type === \"f\"\n      );\n\n      return extend(\n        fields,\n        foreignKeyConstraints.reduce((memo, constraint) => {\n          if (omit(constraint, \"read\")) {\n            return memo;\n          }\n          const gqlTableType = pgGetGqlTypeByTypeIdAndModifier(\n            table.type.id,\n            null\n          );\n          const tableTypeName = gqlTableType.name;\n          if (!gqlTableType) {\n            debug(\n              `Could not determine type for table with id ${constraint.classId}`\n            );\n            return memo;\n          }\n          const foreignTable =\n            introspectionResultsByKind.classById[constraint.foreignClassId];\n          const gqlForeignTableType = pgGetGqlTypeByTypeIdAndModifier(\n            foreignTable.type.id,\n            null\n          );\n          const foreignTableTypeName = gqlForeignTableType.name;\n          if (!gqlForeignTableType) {\n            debug(\n              `Could not determine type for foreign table with id ${constraint.foreignClassId}`\n            );\n            return memo;\n          }\n          if (!foreignTable) {\n            throw new Error(\n              `Could not find the foreign table (constraint: ${constraint.name})`\n            );\n          }\n          if (omit(foreignTable, \"read\")) {\n            return memo;\n          }\n          const foreignSchema = foreignTable.namespace;\n\n          const keys = constraint.keyAttributes;\n          const foreignKeys = constraint.foreignKeyAttributes;\n          if (!keys.every(_ => _) || !foreignKeys.every(_ => _)) {\n            throw new Error(\"Could not find key columns!\");\n          }\n          if (keys.some(key => omit(key, \"read\"))) {\n            return memo;\n          }\n          if (foreignKeys.some(key => omit(key, \"read\"))) {\n            return memo;\n          }\n\n          const fieldName = inflection.singleRelationByKeys(\n            keys,\n            foreignTable,\n            table,\n            constraint\n          );\n\n          memo = extend(\n            memo,\n            {\n              [fieldName]: fieldWithHooks(\n                fieldName,\n                ({\n                  getDataFromParsedResolveInfoFragment,\n                  addDataGenerator,\n                }) => {\n                  addDataGenerator(parsedResolveInfoFragment => {\n                    return {\n                      pgQuery: queryBuilder => {\n                        queryBuilder.select(() => {\n                          const resolveData = getDataFromParsedResolveInfoFragment(\n                            parsedResolveInfoFragment,\n                            gqlForeignTableType\n                          );\n                          const foreignTableAlias = sql.identifier(Symbol());\n                          const query = queryFromResolveData(\n                            sql.identifier(\n                              foreignSchema.name,\n                              foreignTable.name\n                            ),\n                            foreignTableAlias,\n                            resolveData,\n                            {\n                              useAsterisk: false, // Because it's only a single relation, no need\n                              asJson: true,\n                            },\n                            innerQueryBuilder => {\n                              innerQueryBuilder.parentQueryBuilder = queryBuilder;\n                              if (subscriptions && table.primaryKeyConstraint) {\n                                queryBuilder.selectIdentifiers(table);\n                              }\n                              if (\n                                subscriptions &&\n                                foreignTable.primaryKeyConstraint\n                              ) {\n                                innerQueryBuilder.selectIdentifiers(\n                                  foreignTable\n                                );\n                              }\n                              keys.forEach((key, i) => {\n                                innerQueryBuilder.where(\n                                  sql.fragment`${queryBuilder.getTableAlias()}.${sql.identifier(\n                                    key.name\n                                  )} = ${foreignTableAlias}.${sql.identifier(\n                                    foreignKeys[i].name\n                                  )}`\n                                );\n                              });\n                            },\n                            queryBuilder.context,\n                            queryBuilder.rootValue\n                          );\n                          return sql.fragment`(${query})`;\n                        }, getSafeAliasFromAlias(parsedResolveInfoFragment.alias));\n                      },\n                    };\n                  });\n                  return {\n                    description:\n                      constraint.tags.forwardDescription ||\n                      build.wrapDescription(\n                        `Reads a single \\`${foreignTableTypeName}\\` that is related to this \\`${tableTypeName}\\`.`,\n                        \"field\"\n                      ),\n                    type: gqlForeignTableType, // Nullable since RLS may forbid fetching\n                    resolve: (rawData, _args, resolveContext, resolveInfo) => {\n                      const data = isMutationPayload ? rawData.data : rawData;\n                      if (!data) return null;\n                      const safeAlias = getSafeAliasFromResolveInfo(\n                        resolveInfo\n                      );\n                      const record = data[safeAlias];\n                      const liveRecord =\n                        resolveInfo.rootValue &&\n                        resolveInfo.rootValue.liveRecord;\n                      if (record && liveRecord) {\n                        liveRecord(\"pg\", foreignTable, record.__identifiers);\n                      }\n                      return record;\n                    },\n                  };\n                },\n                {\n                  pgFieldIntrospection: constraint,\n                  isPgForwardRelationField: true,\n                }\n              ),\n            },\n            `Forward relation for ${describePgEntity(\n              constraint\n            )}. To rename this relation with a 'Smart Comment':\\n\\n  ${sqlCommentByAddingTags(\n              constraint,\n              {\n                fieldName: \"newNameHere\",\n              }\n            )}`\n          );\n          return memo;\n        }, {}),\n        `Adding forward relations to '${Self.name}'`\n      );\n    },\n    [\"PgForwardRelation\"]\n  );\n}: Plugin);\n"],"file":"PgForwardRelationPlugin.js"}