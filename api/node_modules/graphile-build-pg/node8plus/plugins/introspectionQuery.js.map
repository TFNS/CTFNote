{"version":3,"sources":["../../src/plugins/introspectionQuery.js"],"names":["makeIntrospectionQuery","serverVersionNum","options","pgLegacyFunctionsOnly","pgIgnoreRBAC","unionRBAC","module","exports"],"mappings":";;AACA;;;;;;;;AAQA,SAASA,sBAAT,CACEC,gBADF,EAEEC,OAGC,GAAG,EALN,EAMU;AACR,QAAM;AAAEC,IAAAA,qBAAqB,GAAG,KAA1B;AAAiCC,IAAAA,YAAY,GAAG;AAAhD,MAAyDF,OAA/D;AACA,QAAMG,SAAS,GAAI;;;;;;GAAnB;AAOA,SAAQ;;;;;;;;IAQN,CAACD,YAAD,GAAgB,WAAhB,GAA8B,EAAG;;;;MAI/B,CAACA,YAAD,GAAgBC,SAAhB,GAA4B,EAAG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;QA2D7BJ,gBAAgB,IAAI,MAApB,GACI,mBADJ,GAEI,kDACL;QAECE,qBAAqB,GAChB;;;;;sDADgB,GAOhB;;;;;;;;4GASN;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;QAiGCF,gBAAgB,IAAI,MAApB,GAA6B,iBAA7B,GAAiD,IAAK;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;QA8KtDA,gBAAgB,IAAI,KAApB,GACK;;;;;;;;4CADL,GAUI,EACL;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAtXL;AAwZD;;AAEDK,MAAM,CAACC,OAAP,GAAiB;AACfP,EAAAA;AADe,CAAjB","sourcesContent":["// @flow\n/*\n * IMPORTANT: when editing this file, ensure all operators (e.g. `@>`) are\n * specified in the correct namespace (e.g. `operator(pg_catalog.@>)`). It looks\n * weird, but it prevents clashes with extensions or user code that may\n * overload operators, e.g. extension `intarray` overloads `@>`.\n *\n * NOTE: I'm not doing this with `=` because that way lies madness.\n */\nfunction makeIntrospectionQuery(\n  serverVersionNum: number,\n  options: {\n    pgLegacyFunctionsOnly?: boolean,\n    pgIgnoreRBAC?: boolean,\n  } = {}\n): string {\n  const { pgLegacyFunctionsOnly = false, pgIgnoreRBAC = true } = options;\n  const unionRBAC = `\n    union all\n      select pg_roles.oid _oid, pg_roles.*\n      from pg_roles, accessible_roles, pg_auth_members\n      where pg_auth_members.roleid = pg_roles.oid\n        and pg_auth_members.member = accessible_roles._oid \n  `;\n  return `\\\n-- @see https://www.postgresql.org/docs/9.5/static/catalogs.html\n-- @see https://github.com/graphile/graphile-engine/blob/master/packages/graphile-build-pg/src/plugins/introspectionQuery.js\n--\n-- ## Parameters\n-- - \\`$1\\`: An array of strings that represent the namespaces we are introspecting.\n-- - \\`$2\\`: set true to include functions/tables/etc that come from extensions\nwith\n  ${!pgIgnoreRBAC ? \"recursive\" : \"\"} accessible_roles(_oid) as (\n    select oid _oid, pg_roles.*\n    from pg_roles\n    where rolname = current_user\n    ${!pgIgnoreRBAC ? unionRBAC : \"\"}\n  ),\n  -- @see https://www.postgresql.org/docs/9.5/static/catalog-pg-namespace.html\n  namespace as (\n    select\n      'namespace' as \"kind\",\n      nsp.oid as \"id\",\n      nsp.nspname as \"name\",\n      dsc.description as \"description\"\n    from\n      pg_catalog.pg_namespace as nsp\n      left join pg_catalog.pg_description as dsc on dsc.objoid = nsp.oid and dsc.classoid = 'pg_catalog.pg_namespace'::regclass\n    where\n      nsp.nspname = any ($1)\n    order by\n      nsp.nspname\n  ),\n  -- Select all of the remote procedures we can use in this schema. This comes\n  -- first so that we can select types and classes using the information we get\n  -- from it.\n  --\n  -- @see https://www.postgresql.org/docs/9.6/static/catalog-pg-proc.html\n  procedure as (\n    select\n      'procedure' as \"kind\",\n      pro.oid as \"id\",\n      pro.proname as \"name\",\n      dsc.description as \"description\",\n      pro.pronamespace as \"namespaceId\",\n      nsp.nspname as \"namespaceName\",\n      pro.proisstrict as \"isStrict\",\n      pro.proretset as \"returnsSet\",\n      case\n        when pro.provolatile = 'i' then true\n        when pro.provolatile = 's' then true\n        else false\n      end as \"isStable\",\n      pro.prorettype as \"returnTypeId\",\n      coalesce(pro.proallargtypes, pro.proargtypes) as \"argTypeIds\",\n      coalesce(pro.proargmodes, array[]::text[]) as \"argModes\",\n      coalesce(pro.proargnames, array[]::text[]) as \"argNames\",\n      pro.pronargs as \"inputArgsCount\",\n      pro.pronargdefaults as \"argDefaultsNum\",\n      pro.procost as \"cost\",\n      exists(select 1 from accessible_roles where has_function_privilege(accessible_roles.oid, pro.oid, 'EXECUTE')) as \"aclExecutable\",\n      (select lanname from pg_catalog.pg_language where pg_language.oid = pro.prolang) as \"language\"\n    from\n      pg_catalog.pg_proc as pro\n      left join pg_catalog.pg_description as dsc on dsc.objoid = pro.oid and dsc.classoid = 'pg_catalog.pg_proc'::regclass\n      left join pg_catalog.pg_namespace as nsp on nsp.oid = pro.pronamespace\n    where\n      pro.pronamespace in (select \"id\" from namespace) and\n      -- Currently we don’t support functions with variadic arguments. In the\n      -- future we may, but for now let’s just ignore functions with variadic\n      -- arguments.\n      -- TODO: Variadic arguments.\n      pro.provariadic = 0 and\n      -- Filter our aggregate functions and window functions.\n      ${\n        serverVersionNum >= 110000\n          ? \"pro.prokind = 'f'\"\n          : \"pro.proisagg = false and pro.proiswindow = false\"\n      } and\n      ${\n        pgLegacyFunctionsOnly\n          ? `\\\n      -- We want to make sure the argument mode for all of our arguments is\n      -- \\`IN\\` which means \\`proargmodes\\` will be null.\n      pro.proargmodes is null and\n      -- Do not select procedures that return \\`RECORD\\` (oid 2249).\n      pro.prorettype operator(pg_catalog.<>) 2249 and`\n          : `\\\n      -- We want to make sure the argument modes for all of our arguments are\n      -- \\`IN\\`, \\`OUT\\`, \\`INOUT\\`, or \\`TABLE\\` (not \\`VARIADIC\\`).\n      (pro.proargmodes is null or pro.proargmodes operator(pg_catalog.<@) array['i','o','b','t']::\"char\"[]) and\n      -- Do not select procedures that return \\`RECORD\\` (oid 2249) unless they\n      -- have \\`OUT\\`, \\`INOUT\\`, or \\`TABLE\\` arguments to define the return type.\n      (pro.prorettype operator(pg_catalog.<>) 2249 or pro.proargmodes && array['o','b','t']::\"char\"[]) and\n      -- Do not select procedures that have \\`RECORD\\` arguments.\n      (pro.proallargtypes is null or not (pro.proallargtypes operator(pg_catalog.@>) array[2249::oid])) and`\n      }\n      -- Do not select procedures that create range types. These are utility\n      -- functions that really don’t need to be exposed in an API.\n      pro.proname not in (\n        select typ.typname\n        from pg_catalog.pg_type as typ\n        where typ.typtype = 'r'\n        and typ.typnamespace = pro.pronamespace\n      ) and\n      -- Do not expose trigger functions (type trigger has oid 2279)\n      pro.prorettype operator(pg_catalog.<>) 2279 and\n      -- We don't want functions that will clash with GraphQL (treat them as private)\n      pro.proname not like E'\\\\\\\\_\\\\\\\\_%' and\n      -- We also don’t want procedures that have been defined in our namespace\n      -- twice. This leads to duplicate fields in the API which throws an\n      -- error. In the future we may support this case. For now though, it is\n      -- too complex.\n      (\n        select count(pro2.*)\n        from pg_catalog.pg_proc as pro2\n        where pro2.pronamespace = pro.pronamespace\n        and pro2.proname = pro.proname\n      ) = 1 and\n      ($2 is true or not exists(\n        select 1\n        from pg_catalog.pg_depend\n        where pg_depend.refclassid = 'pg_catalog.pg_extension'::pg_catalog.regclass\n        and pg_depend.deptype = 'e'\n        and pg_depend.classid = 'pg_catalog.pg_proc'::pg_catalog.regclass\n        and pg_depend.objid = pro.oid\n      ))\n    order by\n      pro.pronamespace, pro.proname\n  ),\n  -- @see https://www.postgresql.org/docs/9.5/static/catalog-pg-class.html\n  class as (\n    select\n      'class' as \"kind\",\n      rel.oid as \"id\",\n      rel.relname as \"name\",\n      rel.relkind as \"classKind\",\n      dsc.description as \"description\",\n      rel.relnamespace as \"namespaceId\",\n      nsp.nspname as \"namespaceName\",\n      rel.reltype as \"typeId\",\n      -- Here we determine whether or not we can use this class in a\n      -- \\`SELECT\\`’s \\`FROM\\` clause. In order to determine this we look at them\n      -- \\`relkind\\` column, if it is \\`i\\` (index) or \\`c\\` (composite), we cannot\n      -- select this class. Otherwise we can.\n      rel.relkind not in ('i', 'c') as \"isSelectable\",\n      -- Here we are determining whether we can insert/update/delete a class.\n      -- This is helpful as it lets us detect non-updatable views and then\n      -- exclude them from being inserted/updated/deleted into. For more info\n      -- on how \\`pg_catalog.pg_relation_is_updatable\\` works:\n      --\n      -- - https://www.postgresql.org/message-id/CAEZATCV2_qN9P3zbvADwME_TkYf2gR_X2cLQR4R+pqkwxGxqJg@mail.gmail.com\n      -- - https://github.com/postgres/postgres/blob/2410a2543e77983dab1f63f48b2adcd23dba994e/src/backend/utils/adt/misc.c#L684\n      -- - https://github.com/postgres/postgres/blob/3aff33aa687e47d52f453892498b30ac98a296af/src/backend/rewrite/rewriteHandler.c#L2351\n      (pg_catalog.pg_relation_is_updatable(rel.oid, true)::bit(8) operator(pg_catalog.&) B'00010000') = B'00010000' as \"isDeletable\",\n      (pg_catalog.pg_relation_is_updatable(rel.oid, true)::bit(8) operator(pg_catalog.&) B'00001000') = B'00001000' as \"isInsertable\",\n      (pg_catalog.pg_relation_is_updatable(rel.oid, true)::bit(8) operator(pg_catalog.&) B'00000100') = B'00000100' as \"isUpdatable\",\n      exists(select 1 from accessible_roles where has_table_privilege(accessible_roles.oid, rel.oid, 'SELECT')) as \"aclSelectable\",\n      exists(select 1 from accessible_roles where has_table_privilege(accessible_roles.oid, rel.oid, 'INSERT')) as \"aclInsertable\",\n      exists(select 1 from accessible_roles where has_table_privilege(accessible_roles.oid, rel.oid, 'UPDATE')) as \"aclUpdatable\",\n      exists(select 1 from accessible_roles where has_table_privilege(accessible_roles.oid, rel.oid, 'DELETE')) as \"aclDeletable\"\n    from\n      pg_catalog.pg_class as rel\n      left join pg_catalog.pg_description as dsc on dsc.objoid = rel.oid and dsc.objsubid = 0 and dsc.classoid = 'pg_catalog.pg_class'::regclass\n      left join pg_catalog.pg_namespace as nsp on nsp.oid = rel.relnamespace\n    where\n      rel.relpersistence in ('p') and\n      -- We don't want classes that will clash with GraphQL (treat them as private)\n      rel.relname not like E'\\\\\\\\_\\\\\\\\_%' and\n      rel.relkind in ('r', 'v', 'm', 'c', 'f') and\n      ($2 is true or not exists(\n        select 1\n        from pg_catalog.pg_depend\n        where pg_depend.refclassid = 'pg_catalog.pg_extension'::pg_catalog.regclass\n        and pg_depend.deptype = 'e'\n        and pg_depend.classid = 'pg_catalog.pg_class'::pg_catalog.regclass\n        and pg_depend.objid = rel.oid\n      ))\n    order by\n      rel.relnamespace, rel.relname\n  ),\n  -- @see https://www.postgresql.org/docs/9.5/static/catalog-pg-attribute.html\n  attribute as (\n    select\n      'attribute' as \"kind\",\n      att.attrelid as \"classId\",\n      att.attnum as \"num\",\n      att.attname as \"name\",\n      dsc.description as \"description\",\n      att.atttypid as \"typeId\",\n      nullif(att.atttypmod, -1) as \"typeModifier\",\n      att.attnotnull as \"isNotNull\",\n      att.atthasdef as \"hasDefault\",\n      ${serverVersionNum >= 100000 ? \"att.attidentity\" : \"''\"} as \"identity\",\n      exists(select 1 from accessible_roles where has_column_privilege(accessible_roles.oid, att.attrelid, att.attname, 'SELECT')) as \"aclSelectable\",\n      exists(select 1 from accessible_roles where has_column_privilege(accessible_roles.oid, att.attrelid, att.attname, 'INSERT')) as \"aclInsertable\",\n      exists(select 1 from accessible_roles where has_column_privilege(accessible_roles.oid, att.attrelid, att.attname, 'UPDATE')) as \"aclUpdatable\",\n      -- https://git.postgresql.org/gitweb/?p=postgresql.git;a=commit;h=c62dd80cdf149e2792b13c13777a539f5abb0370\n      att.attacl is not null and exists(select 1 from aclexplode(att.attacl) aclitem where aclitem.privilege_type = 'SELECT' and grantee in (select oid from accessible_roles)) as \"columnLevelSelectGrant\"\n    from\n      pg_catalog.pg_attribute as att\n      left join pg_catalog.pg_description as dsc on dsc.objoid = att.attrelid and dsc.objsubid = att.attnum and dsc.classoid = 'pg_catalog.pg_class'::regclass\n    where\n      att.attrelid in (select \"id\" from class) and\n      att.attnum > 0 and\n      -- We don't want attributes that will clash with GraphQL (treat them as private)\n      att.attname not like E'\\\\\\\\_\\\\\\\\_%' and\n      not att.attisdropped\n    order by\n      att.attrelid, att.attnum\n  ),\n  -- @see https://www.postgresql.org/docs/9.5/static/catalog-pg-type.html\n  type as (\n    -- Use another \\`WITH\\` statement here, because our \\`WHERE\\` clause will need\n    -- to use it.\n    with type_all as (\n      select\n        'type' as \"kind\",\n        typ.oid as \"id\",\n        typ.typname as \"name\",\n        dsc.description as \"description\",\n        typ.typnamespace as \"namespaceId\",\n        -- We include the namespace name in types only because we select so\n        -- many types that are outside of our core set of namespaces. Having\n        -- the namespace name is super helpful when generating SQL, so\n        -- conditionally having namespace names for types is a pain.\n        nsp.nspname as \"namespaceName\",\n        typ.typtype as \"type\",\n        typ.typcategory as \"category\",\n        typ.typnotnull as \"domainIsNotNull\",\n        nullif(typ.typelem, 0) as \"arrayItemTypeId\",\n        typ.typlen as \"typeLength\",\n        (typ.typelem <> 0 and typ.typlen = -1) as \"isPgArray\",\n        nullif(typ.typrelid, 0) as \"classId\",\n        nullif(typ.typbasetype, 0) as \"domainBaseTypeId\",\n        nullif(typ.typtypmod, -1) as \"domainTypeModifier\",\n        typ.typdefaultbin is not null as \"domainHasDefault\",\n        -- If this type is an enum type, let’s select all of its enum variants.\n        --\n        -- @see https://www.postgresql.org/docs/9.5/static/catalog-pg-enum.html\n        case\n          when typ.typtype = 'e' then array(\n            select enm.enumlabel\n            from pg_catalog.pg_enum as enm\n            where enm.enumtypid = typ.oid\n            order by enm.enumsortorder\n          )\n          else null\n        end as \"enumVariants\",\n        -- If this type is a range type, we want to select the sub type of the\n        -- range.\n        --\n        -- @see https://www.postgresql.org/docs/9.6/static/catalog-pg-range.html\n        case\n          when typ.typtype = 'r' then (\n            select rng.rngsubtype\n            from pg_catalog.pg_range as rng\n            where rng.rngtypid = typ.oid\n            limit 1\n          )\n          else null\n        end as \"rangeSubTypeId\"\n      from\n        pg_catalog.pg_type as typ\n        left join pg_catalog.pg_description as dsc on dsc.objoid = typ.oid and dsc.classoid = 'pg_catalog.pg_type'::regclass\n        left join pg_catalog.pg_namespace as nsp on nsp.oid = typ.typnamespace\n    )\n    select\n      *\n    from\n      type_all as typ\n    where\n      typ.id in (\n        select \"typeId\" from class\n      union all\n        select \"typeId\" from attribute\n      union all\n        select \"returnTypeId\" from procedure\n      union all\n        select unnest(\"argTypeIds\") from procedure\n      union all\n      -- If this type is a base type for *any* domain type, we will include it\n      -- in our selection. This may mean we fetch more types than we need, but\n      -- the alternative is to do some funky SQL recursion which would be hard\n      -- code to read. So we prefer code readability over selecting like 3 or\n      -- 4 less type rows.\n      --\n      -- We also do this for range sub types and array item types.\n        select \"domainBaseTypeId\" from type_all\n      union all\n        select \"rangeSubTypeId\" from type_all\n      union all\n        select \"arrayItemTypeId\" from type_all\n      )\n    order by\n      \"namespaceId\", \"name\"\n  ),\n  -- @see https://www.postgresql.org/docs/9.5/static/catalog-pg-constraint.html\n  \"constraint\" as (\n    select distinct on (con.conrelid, con.conkey, con.confrelid, con.confkey)\n      'constraint' as \"kind\",\n      con.oid as \"id\",\n      con.conname as \"name\",\n      con.contype as \"type\",\n      con.conrelid as \"classId\",\n      nullif(con.confrelid, 0) as \"foreignClassId\",\n      dsc.description as \"description\",\n      con.conkey as \"keyAttributeNums\",\n      con.confkey as \"foreignKeyAttributeNums\"\n    from\n      pg_catalog.pg_constraint as con\n      inner join class on (con.conrelid = class.id)\n      left join pg_catalog.pg_description as dsc on dsc.objoid = con.oid and dsc.classoid = 'pg_catalog.pg_constraint'::regclass\n    where\n      -- Only get constraints for classes we have selected.\n      con.conrelid in (select \"id\" from class where \"namespaceId\" in (select \"id\" from namespace)) and\n      case\n        -- If this is a foreign key constraint, we want to ensure that the\n        -- foreign class is also in the list of classes we have already\n        -- selected.\n        when con.contype = 'f' then con.confrelid in (select \"id\" from class where \"namespaceId\" in (select \"id\" from namespace))\n        -- Otherwise, this should be true.\n        else true\n      end and\n      -- We only want foreign key, primary key, and unique constraints. We\n      -- made add support for more constraints in the future.\n      con.contype in ('f', 'p', 'u')\n    order by\n      con.conrelid, con.conkey, con.confrelid, con.confkey, con.conname\n  ),\n  -- @see https://www.postgresql.org/docs/9.5/static/catalog-pg-extension.html\n  \"extension\" as (\n    select\n      'extension' as \"kind\",\n      ext.oid as \"id\",\n      ext.extname as \"name\",\n      ext.extnamespace as \"namespaceId\",\n      nsp.nspname as \"namespaceName\",\n      ext.extrelocatable as \"relocatable\",\n      ext.extversion as \"version\",\n      ext.extconfig as \"configurationClassIds\",\n      dsc.description as \"description\"\n    from\n      pg_catalog.pg_extension as ext\n      left join pg_catalog.pg_description as dsc on dsc.objoid = ext.oid and dsc.classoid = 'pg_catalog.pg_extension'::regclass\n      left join pg_catalog.pg_namespace as nsp on nsp.oid = ext.extnamespace\n    order by\n      ext.extname, ext.oid\n  ),\n  -- @see https://www.postgresql.org/docs/9.5/static/catalog-pg-index.html\n  \"indexes\" as (\n    select\n      'index' as \"kind\",\n      idx.indexrelid as \"id\",\n      idx_more.relname as \"name\",\n      nsp.nspname as \"namespaceName\",\n      idx.indrelid as \"classId\",\n      idx.indnatts as \"numberOfAttributes\",\n      idx.indisunique as \"isUnique\",\n      idx.indisprimary as \"isPrimary\",\n      idx.indimmediate as \"isImmediate\", -- enforce uniqueness immediately on insert\n      idx.indisreplident as \"isReplicaIdentity\",\n      idx.indisvalid as \"isValid\", -- if false, don't use for queries\n      idx.indpred is not null as \"isPartial\", -- if true, index is not on on rows.\n      idx.indkey as \"attributeNums\",\n      am.amname as \"indexType\",\n      ${\n        serverVersionNum >= 90600\n          ? `\\\n      (\n        select array_agg(pg_index_column_has_property(idx.indexrelid,n::int2,'asc'))\n        from unnest(idx.indkey) with ordinality as ord(key,n)\n      ) as \"attributePropertiesAsc\",\n      (\n        select array_agg(pg_index_column_has_property(idx.indexrelid,n::int2,'nulls_first'))\n        from unnest(idx.indkey) with ordinality as ord(key,n)\n      ) as \"attributePropertiesNullsFirst\",`\n          : \"\"\n      }\n      dsc.description as \"description\"\n    from\n      pg_catalog.pg_index as idx\n      inner join pg_catalog.pg_class idx_more on (idx.indexrelid = idx_more.oid)\n      inner join class on (idx.indrelid = class.id)\n      inner join pg_catalog.pg_namespace as nsp on (nsp.oid = idx_more.relnamespace)\n      inner join pg_catalog.pg_am as am on (am.oid = idx_more.relam)\n      left join pg_catalog.pg_description as dsc on dsc.objoid = idx.indexrelid and dsc.objsubid = 0 and dsc.classoid = 'pg_catalog.pg_class'::regclass\n    where\n      idx.indislive is not false and\n      idx.indisexclusion is not true and -- exclusion index\n      idx.indcheckxmin is not true and -- always valid?\n      idx.indpred is null -- no partial index predicate\n    order by\n      idx.indrelid, idx.indexrelid\n  )\nselect row_to_json(x) as object from namespace as x\nunion all\nselect row_to_json(x) as object from class as x\nunion all\nselect row_to_json(x) as object from attribute as x\nunion all\nselect row_to_json(x) as object from type as x\nunion all\nselect row_to_json(x) as object from \"constraint\" as x\nunion all\nselect row_to_json(x) as object from procedure as x\nunion all\nselect row_to_json(x) as object from extension as x\nunion all\nselect row_to_json(x) as object from indexes as x\n;\n`;\n}\n\nmodule.exports = {\n  makeIntrospectionQuery,\n};\n"],"file":"introspectionQuery.js"}