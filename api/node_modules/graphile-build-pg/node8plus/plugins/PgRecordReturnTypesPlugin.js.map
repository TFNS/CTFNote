{"version":3,"sources":["../../src/plugins/PgRecordReturnTypesPlugin.js"],"names":["PgRecordReturnTypesPlugin","builder","hook","_","build","newWithHooks","pgIntrospectionResultsByKind","introspectionResultsByKind","pgGetGqlTypeByTypeIdAndModifier","graphql","GraphQLObjectType","inflection","pgOmit","omit","describePgEntity","sqlCommentByAddingTags","pgSql","sql","pgGetSelectValueForFieldAndTypeAndModifier","getSelectValueForFieldAndTypeAndModifier","getSafeAliasFromResolveInfo","getSafeAliasFromAlias","pg2gqlForType","procedure","forEach","proc","namespace","returnType","typeById","returnTypeId","id","argTypes","argTypeIds","reduce","prev","typeId","idx","argModes","length","push","argModesWithOutput","outputArgNames","includes","argNames","outputArgTypes","isMutation","isStable","firstArgType","computed","type","class","namespaceId","name","startsWith","procFieldName","functionMutationName","computedColumn","substr","functionQueryName","recordFunctionReturnType","description","wrapDescription","fields","fieldWithHooks","memo","outputArgName","fieldName","functionOutputFieldName","fieldType","Error","fieldContext","addDataGenerator","parsedResolveInfoFragment","safeAlias","alias","pgQuery","queryBuilder","select","fragment","getTableAlias","identifier","convertFromPg","resolve","data","_args","_context","resolveInfo","__origin","resultTypeName","isRecordReturnType","pgIntrospection"],"mappings":";;;;;;;IAGyBA,yB,GAAT,SAASA,yBAAT,CAAmCC,OAAnC,EAA4C;AAC1DA,EAAAA,OAAO,CAACC,IAAR,CACE,MADF,EAEE,CAACC,CAAD,EAAIC,KAAJ,KAAc;AACZ,UAAM;AACJC,MAAAA,YADI;AAEJC,MAAAA,4BAA4B,EAAEC,0BAF1B;AAGJC,MAAAA,+BAHI;AAIJC,MAAAA,OAAO,EAAE;AAAEC,QAAAA;AAAF,OAJL;AAKJC,MAAAA,UALI;AAMJC,MAAAA,MAAM,EAAEC,IANJ;AAOJC,MAAAA,gBAPI;AAQJC,MAAAA,sBARI;AASJC,MAAAA,KAAK,EAAEC,GATH;AAUJC,MAAAA,0CAA0C,EAAEC,wCAVxC;AAWJC,MAAAA,2BAXI;AAYJC,MAAAA,qBAZI;AAaJC,MAAAA;AAbI,QAcFlB,KAdJ;AAgBAG,IAAAA,0BAA0B,CAACgB,SAA3B,CAAqCC,OAArC,CAA6CC,IAAI,IAAI;AACnD;AACA,UAAI,CAACA,IAAI,CAACC,SAAV,EAAqB;AACrB,UAAIb,IAAI,CAACY,IAAD,EAAO,SAAP,CAAR,EAA2B;AAE3B,YAAME,UAAU,GACdpB,0BAA0B,CAACqB,QAA3B,CAAoCH,IAAI,CAACI,YAAzC,CADF;;AAEA,UAAIF,UAAU,CAACG,EAAX,KAAkB,MAAtB,EAA8B;AAC5B;AACD;;AACD,YAAMC,QAAQ,GAAGN,IAAI,CAACO,UAAL,CAAgBC,MAAhB,CAAuB,CAACC,IAAD,EAAOC,MAAP,EAAeC,GAAf,KAAuB;AAC7D,YACEX,IAAI,CAACY,QAAL,CAAcC,MAAd,KAAyB,CAAzB,IAA8B;AAC9Bb,QAAAA,IAAI,CAACY,QAAL,CAAcD,GAAd,MAAuB,GADvB,IAC8B;AAC9BX,QAAAA,IAAI,CAACY,QAAL,CAAcD,GAAd,MAAuB,GAHzB,CAG6B;AAH7B,UAIE;AACAF,YAAAA,IAAI,CAACK,IAAL,CAAUhC,0BAA0B,CAACqB,QAA3B,CAAoCO,MAApC,CAAV;AACD;;AACD,eAAOD,IAAP;AACD,OATgB,EASd,EATc,CAAjB;AAUA,YAAMM,kBAAkB,GAAG,CACzB,GADyB,EACpB;AACL,SAFyB,EAEpB;AACL,SAHyB,CAGpB;AAHoB,OAA3B;AAKA,YAAMC,cAAc,GAAGhB,IAAI,CAACO,UAAL,CAAgBC,MAAhB,CAAuB,CAACC,IAAD,EAAO/B,CAAP,EAAUiC,GAAV,KAAkB;AAC9D,YAAII,kBAAkB,CAACE,QAAnB,CAA4BjB,IAAI,CAACY,QAAL,CAAcD,GAAd,CAA5B,CAAJ,EAAqD;AACnDF,UAAAA,IAAI,CAACK,IAAL,CAAUd,IAAI,CAACkB,QAAL,CAAcP,GAAd,KAAsB,EAAhC;AACD;;AACD,eAAOF,IAAP;AACD,OALsB,EAKpB,EALoB,CAAvB;AAMA,YAAMU,cAAc,GAAGnB,IAAI,CAACO,UAAL,CAAgBC,MAAhB,CAAuB,CAACC,IAAD,EAAOC,MAAP,EAAeC,GAAf,KAAuB;AACnE,YAAII,kBAAkB,CAACE,QAAnB,CAA4BjB,IAAI,CAACY,QAAL,CAAcD,GAAd,CAA5B,CAAJ,EAAqD;AACnDF,UAAAA,IAAI,CAACK,IAAL,CAAUhC,0BAA0B,CAACqB,QAA3B,CAAoCO,MAApC,CAAV;AACD;;AACD,eAAOD,IAAP;AACD,OALsB,EAKpB,EALoB,CAAvB;AAMA,YAAMW,UAAU,GAAG,CAACpB,IAAI,CAACqB,QAAzB;AACA,YAAMC,YAAY,GAAGhB,QAAQ,CAAC,CAAD,CAA7B;AACA,YAAMiB,QAAQ,GACZD,YAAY,IACZA,YAAY,CAACE,IAAb,KAAsB,GADtB,IAEAF,YAAY,CAACG,KAFb,IAGAH,YAAY,CAACI,WAAb,KAA6B1B,IAAI,CAAC0B,WAHlC,IAIA1B,IAAI,CAAC2B,IAAL,CAAUC,UAAV,CAAsB,GAAEN,YAAY,CAACK,IAAK,GAA1C,CALF;AAMA,YAAME,aAAa,GAAGT,UAAU,GAC5BlC,UAAU,CAAC4C,oBAAX,CAAgC9B,IAAhC,CAD4B,GAE5BuB,QAAQ,GACRrC,UAAU,CAAC6C,cAAX,CACE/B,IAAI,CAAC2B,IAAL,CAAUK,MAAV,CAAiBV,YAAY,CAACK,IAAb,CAAkBd,MAAlB,GAA2B,CAA5C,CADF,EAEEb,IAFF,CADQ,GAKRd,UAAU,CAAC+C,iBAAX,CAA6BjC,IAA7B,CAPJ;AAQApB,MAAAA,YAAY,CACVK,iBADU,EAEV;AACE0C,QAAAA,IAAI,EAAEzC,UAAU,CAACgD,wBAAX,CAAoClC,IAApC,CADR;AAEEmC,QAAAA,WAAW,EAAExD,KAAK,CAACyD,eAAN,CACV,4BAA2BP,aAAc,MACxCT,UAAU,GAAG,UAAH,GAAgB,OAC3B,GAHU,EAIX,MAJW,CAFf;AAQEiB,QAAAA,MAAM,EAAE,CAAC;AAAEC,UAAAA;AAAF,SAAD,KAAwB;AAC9B,iBAAOtB,cAAc,CAACR,MAAf,CAAsB,CAAC+B,IAAD,EAAOC,aAAP,EAAsB7B,GAAtB,KAA8B;AACzD,kBAAM8B,SAAS,GAAGvD,UAAU,CAACwD,uBAAX,CAChB1C,IADgB,EAEhBwC,aAFgB,EAGhB7B,GAAG,GAAG,CAHU,CAAlB;AAKA,kBAAMgC,SAAS,GAAG5D,+BAA+B,CAC/CoC,cAAc,CAACR,GAAD,CAAd,CAAoBN,EAD2B,EAE/C,IAF+C,CAAjD;;AAIA,gBAAIkC,IAAI,CAACE,SAAD,CAAR,EAAqB;AACnB,oBAAM,IAAIG,KAAJ,CACH,iCAAgCH,SAAU,eAAcpD,gBAAgB,CACvEW,IADuE,CAEvE,wCAHE,CAAN;AAKD;;AACDuC,YAAAA,IAAI,CAACE,SAAD,CAAJ,GAAkBH,cAAc,CAC9BG,SAD8B,EAE9BI,YAAY,IAAI;AACd,oBAAM;AAAEC,gBAAAA;AAAF,kBAAuBD,YAA7B;AACAC,cAAAA,gBAAgB,CAACC,yBAAyB,IAAI;AAC5C,sBAAMC,SAAS,GAAGpD,qBAAqB,CACrCmD,yBAAyB,CAACE,KADW,CAAvC;AAGA,uBAAO;AACLC,kBAAAA,OAAO,EAAEC,YAAY,IAAI;AACvBA,oBAAAA,YAAY,CAACC,MAAb,CACE1D,wCAAwC,CACtCiD,SADsC,EAEtCE,YAFsC,EAGtCE,yBAHsC,EAItCvD,GAAG,CAAC6D,QAAS,IAAGF,YAAY,CAACG,aAAb,EAA6B,IAAG9D,GAAG,CAAC+D,UAAJ,EAC9C;AACA;AACA;AACAf,oBAAAA,aAAa,KAAK,EAAlB,GACIA,aADJ,GAEK,SAAQ7B,GAAG,GAAG,CAAE,EANyB,CAO9C,GAXoC,EAYtCQ,cAAc,CAACR,GAAD,CAZwB,EAatC,IAbsC,CAD1C,EAgBEqC,SAhBF;AAkBD;AApBI,iBAAP;AAsBD,eA1Be,CAAhB;AA2BA,oBAAMQ,aAAa,GAAG3D,aAAa,CAACsB,cAAc,CAACR,GAAD,CAAf,CAAnC;AACA,qBAAO;AACLa,gBAAAA,IAAI,EAAEmB,SADD;;AAELc,gBAAAA,OAAO,CAACC,IAAD,EAAOC,KAAP,EAAcC,QAAd,EAAwBC,WAAxB,EAAqC;AAC1C,wBAAMb,SAAS,GAAGrD,2BAA2B,CAC3CkE,WAD2C,CAA7C;AAGA,yBAAOL,aAAa,CAACE,IAAI,CAACV,SAAD,CAAL,CAApB;AACD;;AAPI,eAAP;AASD,aAzC6B,EA0C9B,EA1C8B,CAAhC;AA4CA,mBAAOT,IAAP;AACD,WA9DM,EA8DJ,EA9DI,CAAP;AA+DD;AAxEH,OAFU,EA4EV;AACEuB,QAAAA,QAAQ,EAAG,iCAAgCzE,gBAAgB,CACzDW,IADyD,CAEzD,uGAAsGV,sBAAsB,CAC5HU,IAD4H,EAE5H;AACE2B,UAAAA,IAAI,EAAE;AADR,SAF4H,CAK5H,0FAAyFrC,sBAAsB,CAC/GU,IAD+G,EAE/G;AACE+D,UAAAA,cAAc,EAAE;AADlB,SAF+G,CAK/G,EAbJ;AAcEC,QAAAA,kBAAkB,EAAE,IAdtB;AAeEC,QAAAA,eAAe,EAAEjE;AAfnB,OA5EU,CAAZ;AA8FD,KAnJD;AAoJA,WAAOtB,CAAP;AACD,GAxKH,EAyKE,CAAC,qBAAD,CAzKF;AA2KD,C","sourcesContent":["// @flow\nimport type { Plugin } from \"graphile-build\";\n\nexport default (function PgRecordReturnTypesPlugin(builder) {\n  builder.hook(\n    \"init\",\n    (_, build) => {\n      const {\n        newWithHooks,\n        pgIntrospectionResultsByKind: introspectionResultsByKind,\n        pgGetGqlTypeByTypeIdAndModifier,\n        graphql: { GraphQLObjectType },\n        inflection,\n        pgOmit: omit,\n        describePgEntity,\n        sqlCommentByAddingTags,\n        pgSql: sql,\n        pgGetSelectValueForFieldAndTypeAndModifier: getSelectValueForFieldAndTypeAndModifier,\n        getSafeAliasFromResolveInfo,\n        getSafeAliasFromAlias,\n        pg2gqlForType,\n      } = build;\n\n      introspectionResultsByKind.procedure.forEach(proc => {\n        // PERFORMANCE: These used to be .filter(...) calls\n        if (!proc.namespace) return;\n        if (omit(proc, \"execute\")) return;\n\n        const returnType =\n          introspectionResultsByKind.typeById[proc.returnTypeId];\n        if (returnType.id !== \"2249\") {\n          return;\n        }\n        const argTypes = proc.argTypeIds.reduce((prev, typeId, idx) => {\n          if (\n            proc.argModes.length === 0 || // all args are `in`\n            proc.argModes[idx] === \"i\" || // this arg is `in`\n            proc.argModes[idx] === \"b\" // this arg is `inout`\n          ) {\n            prev.push(introspectionResultsByKind.typeById[typeId]);\n          }\n          return prev;\n        }, []);\n        const argModesWithOutput = [\n          \"o\", // OUT,\n          \"b\", // INOUT\n          \"t\", // TABLE\n        ];\n        const outputArgNames = proc.argTypeIds.reduce((prev, _, idx) => {\n          if (argModesWithOutput.includes(proc.argModes[idx])) {\n            prev.push(proc.argNames[idx] || \"\");\n          }\n          return prev;\n        }, []);\n        const outputArgTypes = proc.argTypeIds.reduce((prev, typeId, idx) => {\n          if (argModesWithOutput.includes(proc.argModes[idx])) {\n            prev.push(introspectionResultsByKind.typeById[typeId]);\n          }\n          return prev;\n        }, []);\n        const isMutation = !proc.isStable;\n        const firstArgType = argTypes[0];\n        const computed =\n          firstArgType &&\n          firstArgType.type === \"c\" &&\n          firstArgType.class &&\n          firstArgType.namespaceId === proc.namespaceId &&\n          proc.name.startsWith(`${firstArgType.name}_`);\n        const procFieldName = isMutation\n          ? inflection.functionMutationName(proc)\n          : computed\n          ? inflection.computedColumn(\n              proc.name.substr(firstArgType.name.length + 1),\n              proc\n            )\n          : inflection.functionQueryName(proc);\n        newWithHooks(\n          GraphQLObjectType,\n          {\n            name: inflection.recordFunctionReturnType(proc),\n            description: build.wrapDescription(\n              `The return type of our \\`${procFieldName}\\` ${\n                isMutation ? \"mutation\" : \"query\"\n              }.`,\n              \"type\"\n            ),\n            fields: ({ fieldWithHooks }) => {\n              return outputArgNames.reduce((memo, outputArgName, idx) => {\n                const fieldName = inflection.functionOutputFieldName(\n                  proc,\n                  outputArgName,\n                  idx + 1\n                );\n                const fieldType = pgGetGqlTypeByTypeIdAndModifier(\n                  outputArgTypes[idx].id,\n                  null\n                );\n                if (memo[fieldName]) {\n                  throw new Error(\n                    `Tried to register field name '${fieldName}' twice in '${describePgEntity(\n                      proc\n                    )}'; the argument names are too similar.`\n                  );\n                }\n                memo[fieldName] = fieldWithHooks(\n                  fieldName,\n                  fieldContext => {\n                    const { addDataGenerator } = fieldContext;\n                    addDataGenerator(parsedResolveInfoFragment => {\n                      const safeAlias = getSafeAliasFromAlias(\n                        parsedResolveInfoFragment.alias\n                      );\n                      return {\n                        pgQuery: queryBuilder => {\n                          queryBuilder.select(\n                            getSelectValueForFieldAndTypeAndModifier(\n                              fieldType,\n                              fieldContext,\n                              parsedResolveInfoFragment,\n                              sql.fragment`(${queryBuilder.getTableAlias()}.${sql.identifier(\n                                // According to https://www.postgresql.org/docs/10/static/sql-createfunction.html,\n                                // \"If you omit the name for an output argument, the system will choose a default column name.\"\n                                // In PG 9.x and 10, the column names appear to be assigned with a `column` prefix.\n                                outputArgName !== \"\"\n                                  ? outputArgName\n                                  : `column${idx + 1}`\n                              )})`,\n                              outputArgTypes[idx],\n                              null\n                            ),\n                            safeAlias\n                          );\n                        },\n                      };\n                    });\n                    const convertFromPg = pg2gqlForType(outputArgTypes[idx]);\n                    return {\n                      type: fieldType,\n                      resolve(data, _args, _context, resolveInfo) {\n                        const safeAlias = getSafeAliasFromResolveInfo(\n                          resolveInfo\n                        );\n                        return convertFromPg(data[safeAlias]);\n                      },\n                    };\n                  },\n                  {}\n                );\n                return memo;\n              }, {});\n            },\n          },\n          {\n            __origin: `Adding record return type for ${describePgEntity(\n              proc\n            )}. You can rename the function's GraphQL field (and its dependent types) via a 'Smart Comment':\\n\\n  ${sqlCommentByAddingTags(\n              proc,\n              {\n                name: \"newNameHere\",\n              }\n            )}\\n\\nYou can rename just the function's GraphQL result type via a 'Smart Comment':\\n\\n  ${sqlCommentByAddingTags(\n              proc,\n              {\n                resultTypeName: \"newNameHere\",\n              }\n            )}`,\n            isRecordReturnType: true,\n            pgIntrospection: proc,\n          }\n        );\n      });\n      return _;\n    },\n    [\"PgRecordReturnTypes\"]\n  );\n}: Plugin);\n"],"file":"PgRecordReturnTypesPlugin.js"}