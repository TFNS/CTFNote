{"version":3,"sources":["../../src/plugins/PgTablesPlugin.js"],"names":["base64","str","Buffer","from","String","toString","hasNonNullKey","row","Array","isArray","__identifiers","every","i","k","Object","prototype","hasOwnProperty","call","PgTablesPlugin","builder","pgForbidSetofFunctionsToReturnNull","subscriptions","handleNullRow","_identifiers","identifiers","hook","_","build","getNodeIdForTypeAndIdentifiers","nodeIdFieldName","newWithHooks","getSafeAliasFromResolveInfo","pgSql","sql","pgIntrospectionResultsByKind","introspectionResultsByKind","getTypeByName","pgGetGqlTypeByTypeIdAndModifier","pgGetGqlInputTypeByTypeIdAndModifier","pgRegisterGqlTypeByTypeId","pgRegisterGqlInputTypeByTypeId","pg2GqlMapper","gql2pg","graphql","GraphQLObjectType","GraphQLNonNull","GraphQLID","GraphQLList","GraphQLInputObjectType","inflection","describePgEntity","sqlCommentByAddingTags","pgField","nullableIf","condition","Type","Cursor","class","forEach","table","tags","enum","tablePgType","type","Error","arrayTablePgType","arrayType","primaryKeyConstraint","primaryKeys","keyAttributes","attributes","tableTypeName","tableType","shouldHaveNodeId","isSelectable","namespace","length","TableType","TablePatchType","TableBaseInputType","id","cb","description","name","interfaces","builtin","fields","addDataGeneratorForField","Self","pgQuery","queryBuilder","selectIdentifiers","wrapDescription","resolve","data","finalIdentifiers","map","identifier","idx","key","domainBaseType","int","parseInt","Number","MAX_SAFE_INTEGER","__origin","pgIntrospection","isPgRowType","isPgCompoundType","isPgCompositeType","pgCreateInputFields","pgPatchInputFields","pgBaseInputFields","inputType","isInputType","pgAddSubfield","fieldName","attrName","pgType","spec","typeModifier","patchType","isPgPatch","baseInputType","isPgBaseInput","unmap","obj","modifier","fieldLookup","attr2sql","attr","column","inputField","v","fragment","isFake","namespaceName","null","join","EdgeType","edge","fieldWithHooks","cursor","addDataGenerator","usesCursor","__cursor","JSON","stringify","isCursorField","node","_args","resolveContext","resolveInfo","safeAlias","record","liveRecord","rootValue","withQueryBuilder","isEdgeType","isPgRowEdgeType","nodeType","PageInfo","connection","recurseDataGeneratorsForField","nodes","entry","edges","_context","hoistCursor","pageInfo","isConnectionType","isPgRowConnectionType","edgeType","_set","RelevantTableInputType"],"mappings":"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","sourcesContent":["// @flow\nimport type { Plugin } from \"graphile-build\";\nconst base64 = str => Buffer.from(String(str)).toString(\"base64\");\n\nconst hasNonNullKey = row => {\n  if (\n    Array.isArray(row.__identifiers) &&\n    row.__identifiers.every(i => i != null)\n  ) {\n    return true;\n  }\n  for (const k in row) {\n    if (Object.prototype.hasOwnProperty.call(row, k)) {\n      if ((k[0] !== \"_\" || k[1] !== \"_\") && row[k] !== null) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\nexport default (function PgTablesPlugin(\n  builder,\n  { pgForbidSetofFunctionsToReturnNull = false, subscriptions = false }\n) {\n  const handleNullRow = pgForbidSetofFunctionsToReturnNull\n    ? (row, _identifiers) => row\n    : (row, identifiers) => {\n        if ((identifiers && hasNonNullKey(identifiers)) || hasNonNullKey(row)) {\n          return row;\n        } else {\n          return null;\n        }\n      };\n\n  builder.hook(\n    \"init\",\n    (_, build) => {\n      const {\n        getNodeIdForTypeAndIdentifiers,\n        nodeIdFieldName,\n        newWithHooks,\n        getSafeAliasFromResolveInfo,\n        pgSql: sql,\n        pgIntrospectionResultsByKind: introspectionResultsByKind,\n        getTypeByName,\n        pgGetGqlTypeByTypeIdAndModifier,\n        pgGetGqlInputTypeByTypeIdAndModifier,\n        pgRegisterGqlTypeByTypeId,\n        pgRegisterGqlInputTypeByTypeId,\n        pg2GqlMapper,\n        gql2pg,\n        graphql: {\n          GraphQLObjectType,\n          GraphQLNonNull,\n          GraphQLID,\n          GraphQLList,\n          GraphQLInputObjectType,\n        },\n        inflection,\n        describePgEntity,\n        sqlCommentByAddingTags,\n        pgField,\n      } = build;\n\n      const nullableIf = (condition, Type) =>\n        condition ? Type : new GraphQLNonNull(Type);\n      const Cursor = getTypeByName(\"Cursor\");\n\n      introspectionResultsByKind.class.forEach(table => {\n        if (table.tags.enum) {\n          return;\n        }\n        const tablePgType = table.type;\n        if (!tablePgType) {\n          throw new Error(\"Could not determine the type for this table\");\n        }\n        const arrayTablePgType = tablePgType.arrayType;\n        const primaryKeyConstraint = table.primaryKeyConstraint;\n        const primaryKeys =\n          primaryKeyConstraint && primaryKeyConstraint.keyAttributes;\n        const attributes = table.attributes;\n        const tableTypeName = inflection.tableType(table);\n        const shouldHaveNodeId: boolean =\n          nodeIdFieldName &&\n          table.isSelectable &&\n          table.namespace &&\n          primaryKeys &&\n          primaryKeys.length\n            ? true\n            : false;\n        let TableType;\n        let TablePatchType;\n        let TableBaseInputType;\n        pgRegisterGqlTypeByTypeId(\n          tablePgType.id,\n          cb => {\n            if (TableType) {\n              return TableType;\n            }\n            if (pg2GqlMapper[tablePgType.id]) {\n              // Already handled\n              throw new Error(\n                `Register was called but there's already a mapper in place for '${tablePgType.id}'!`\n              );\n            }\n            TableType = newWithHooks(\n              GraphQLObjectType,\n              {\n                description: table.description || tablePgType.description,\n                name: tableTypeName,\n                interfaces: () => {\n                  if (shouldHaveNodeId) {\n                    return [getTypeByName(inflection.builtin(\"Node\"))];\n                  } else {\n                    return [];\n                  }\n                },\n                fields: ({ addDataGeneratorForField, Self }) => {\n                  const fields = {};\n                  if (shouldHaveNodeId) {\n                    // Enable nodeId interface\n                    addDataGeneratorForField(nodeIdFieldName, () => {\n                      return {\n                        pgQuery: queryBuilder => {\n                          queryBuilder.selectIdentifiers(table);\n                        },\n                      };\n                    });\n                    fields[nodeIdFieldName] = {\n                      description: build.wrapDescription(\n                        \"A globally unique identifier. Can be used in various places throughout the system to identify this single value.\",\n                        \"field\"\n                      ),\n                      type: new GraphQLNonNull(GraphQLID),\n                      resolve(data) {\n                        const identifiers = data.__identifiers;\n                        if (!identifiers) {\n                          return null;\n                        }\n                        /*\n                         * For bigint we want NodeIDs to be the same as int up\n                         * to the limits of int, and only to be strings after\n                         * that point.\n                         */\n                        const finalIdentifiers = identifiers.map(\n                          (identifier, idx) => {\n                            const key = primaryKeys[idx];\n                            const type = key.type.domainBaseType || key.type;\n                            if (type.id === \"20\" /* bigint */) {\n                              /*\n                               * When migrating from 'int' to 'bigint' we want\n                               * to maintain nodeIDs in the safe range before\n                               * moving to strings for larger numbers. Since we\n                               * can represent ints up to MAX_SAFE_INTEGER\n                               * (2^53 - 1) fine, we're using that as the\n                               * boundary.\n                               */\n                              const int = parseInt(identifier, 10);\n                              if (\n                                int >= -Number.MAX_SAFE_INTEGER &&\n                                int <= Number.MAX_SAFE_INTEGER\n                              ) {\n                                return int;\n                              }\n                            }\n                            return identifier;\n                          }\n                        );\n                        return getNodeIdForTypeAndIdentifiers(\n                          Self,\n                          ...finalIdentifiers\n                        );\n                      },\n                    };\n                  }\n                  return fields;\n                },\n              },\n              {\n                __origin: `Adding table type for ${describePgEntity(\n                  table\n                )}. You can rename the table's GraphQL type via a 'Smart Comment':\\n\\n  ${sqlCommentByAddingTags(\n                  table,\n                  {\n                    name: \"newNameHere\",\n                  }\n                )}`,\n                pgIntrospection: table,\n                isPgRowType: table.isSelectable,\n                isPgCompoundType: !table.isSelectable, // TODO:v5: remove - typo\n                isPgCompositeType: !table.isSelectable,\n              }\n            );\n            cb(TableType);\n            const pgCreateInputFields = {};\n            const pgPatchInputFields = {};\n            const pgBaseInputFields = {};\n            newWithHooks(\n              GraphQLInputObjectType,\n              {\n                description: build.wrapDescription(\n                  `An input for mutations affecting \\`${tableTypeName}\\``,\n                  \"type\"\n                ),\n                name: inflection.inputType(TableType),\n              },\n              {\n                __origin: `Adding table input type for ${describePgEntity(\n                  table\n                )}. You can rename the table's GraphQL type via a 'Smart Comment':\\n\\n  ${sqlCommentByAddingTags(\n                  table,\n                  {\n                    name: \"newNameHere\",\n                  }\n                )}`,\n                pgIntrospection: table,\n                isInputType: true,\n                isPgRowType: table.isSelectable,\n                isPgCompoundType: !table.isSelectable,\n                pgAddSubfield(fieldName, attrName, pgType, spec, typeModifier) {\n                  pgCreateInputFields[fieldName] = {\n                    name: attrName,\n                    type: pgType,\n                    typeModifier,\n                  };\n                  return spec;\n                },\n              },\n              true // If no fields, skip type automatically\n            );\n\n            if (table.isSelectable) {\n              // XXX: these don't belong here; but we have to keep them here\n              // because third-party code depends on `getTypeByName` to find\n              // them; so we have to register them ahead of time. A better\n              // approach is to use the modifier to specify the type you need,\n              // 'patch' or 'base', so they can be registered just in time.\n              TablePatchType = newWithHooks(\n                GraphQLInputObjectType,\n                {\n                  description: build.wrapDescription(\n                    `Represents an update to a \\`${tableTypeName}\\`. Fields that are set will be updated.`,\n                    \"type\"\n                  ),\n                  name: inflection.patchType(TableType),\n                },\n                {\n                  __origin: `Adding table patch type for ${describePgEntity(\n                    table\n                  )}. You can rename the table's GraphQL type via a 'Smart Comment':\\n\\n  ${sqlCommentByAddingTags(\n                    table,\n                    {\n                      name: \"newNameHere\",\n                    }\n                  )}`,\n                  pgIntrospection: table,\n                  isPgRowType: table.isSelectable,\n                  isPgCompoundType: !table.isSelectable,\n                  isPgPatch: true,\n                  pgAddSubfield(\n                    fieldName,\n                    attrName,\n                    pgType,\n                    spec,\n                    typeModifier\n                  ) {\n                    pgPatchInputFields[fieldName] = {\n                      name: attrName,\n                      type: pgType,\n                      typeModifier,\n                    };\n                    return spec;\n                  },\n                },\n                true // Safe to skip this if no fields support updating\n              );\n              TableBaseInputType = newWithHooks(\n                GraphQLInputObjectType,\n                {\n                  description: build.wrapDescription(\n                    `An input representation of \\`${tableTypeName}\\` with nullable fields.`,\n                    \"type\"\n                  ),\n                  name: inflection.baseInputType(TableType),\n                },\n                {\n                  __origin: `Adding table base input type for ${describePgEntity(\n                    table\n                  )}. You can rename the table's GraphQL type via a 'Smart Comment':\\n\\n  ${sqlCommentByAddingTags(\n                    table,\n                    {\n                      name: \"newNameHere\",\n                    }\n                  )}`,\n                  pgIntrospection: table,\n                  isPgRowType: table.isSelectable,\n                  isPgCompoundType: !table.isSelectable,\n                  isPgBaseInput: true,\n                  pgAddSubfield(\n                    fieldName,\n                    attrName,\n                    pgType,\n                    spec,\n                    typeModifier\n                  ) {\n                    pgBaseInputFields[fieldName] = {\n                      name: attrName,\n                      type: pgType,\n                      typeModifier,\n                    };\n                    return spec;\n                  },\n                }\n              );\n            }\n\n            pg2GqlMapper[tablePgType.id] = {\n              map: _ => _,\n              unmap: (obj, modifier) => {\n                let fieldLookup;\n                if (modifier === \"patch\") {\n                  fieldLookup = pgPatchInputFields;\n                } else if (modifier === \"base\") {\n                  fieldLookup = pgBaseInputFields;\n                } else {\n                  fieldLookup = pgCreateInputFields;\n                }\n\n                const attr2sql = attr => {\n                  // TODO: this should use `fieldInput[*].name` to find the attribute\n                  const fieldName = inflection.column(attr);\n                  const inputField = fieldLookup[fieldName];\n                  const v = obj[fieldName];\n                  if (inputField && v != null) {\n                    const { type, typeModifier } = inputField;\n                    return sql.fragment`${gql2pg(v, type, typeModifier)}::${\n                      type.isFake\n                        ? sql.identifier(\"unknown\")\n                        : sql.identifier(type.namespaceName, type.name)\n                    }`;\n                  } else {\n                    return sql.null; // TODO: return default instead.\n                  }\n                };\n\n                return sql.fragment`row(${sql.join(\n                  attributes.map(attr2sql),\n                  \",\"\n                )})::${\n                  tablePgType.isFake\n                    ? sql.identifier(\"unknown\")\n                    : sql.identifier(\n                        tablePgType.namespaceName,\n                        tablePgType.name\n                      )\n                }`;\n              },\n            };\n\n            const EdgeType = newWithHooks(\n              GraphQLObjectType,\n              {\n                description: build.wrapDescription(\n                  `A \\`${tableTypeName}\\` edge in the connection.`,\n                  \"type\"\n                ),\n                name: inflection.edge(TableType.name),\n                fields: ({ fieldWithHooks }) => {\n                  return {\n                    cursor: fieldWithHooks(\n                      \"cursor\",\n                      ({ addDataGenerator }) => {\n                        addDataGenerator(() => ({\n                          usesCursor: [true],\n                          pgQuery: queryBuilder => {\n                            if (primaryKeys) {\n                              queryBuilder.selectIdentifiers(table);\n                            }\n                          },\n                        }));\n                        return {\n                          description: build.wrapDescription(\n                            \"A cursor for use in pagination.\",\n                            \"field\"\n                          ),\n                          type: Cursor,\n                          resolve(data) {\n                            return (\n                              data.__cursor &&\n                              base64(JSON.stringify(data.__cursor))\n                            );\n                          },\n                        };\n                      },\n                      {\n                        isCursorField: true,\n                      }\n                    ),\n                    node: pgField(\n                      build,\n                      fieldWithHooks,\n                      \"node\",\n                      {\n                        description: build.wrapDescription(\n                          `The \\`${tableTypeName}\\` at the end of the edge.`,\n                          \"field\"\n                        ),\n                        type: nullableIf(\n                          !pgForbidSetofFunctionsToReturnNull,\n                          TableType\n                        ),\n                        resolve(data, _args, resolveContext, resolveInfo) {\n                          const safeAlias = getSafeAliasFromResolveInfo(\n                            resolveInfo\n                          );\n                          const record = handleNullRow(\n                            data[safeAlias],\n                            data.__identifiers\n                          );\n                          const liveRecord =\n                            resolveInfo.rootValue &&\n                            resolveInfo.rootValue.liveRecord;\n                          if (\n                            record &&\n                            primaryKeys &&\n                            liveRecord &&\n                            data.__identifiers\n                          ) {\n                            liveRecord(\"pg\", table, data.__identifiers);\n                          }\n                          return record;\n                        },\n                      },\n                      {},\n                      false,\n                      {\n                        withQueryBuilder: queryBuilder => {\n                          if (subscriptions) {\n                            queryBuilder.selectIdentifiers(table);\n                          }\n                        },\n                      }\n                    ),\n                  };\n                },\n              },\n              {\n                __origin: `Adding table edge type for ${describePgEntity(\n                  table\n                )}. You can rename the table's GraphQL type via a 'Smart Comment':\\n\\n  ${sqlCommentByAddingTags(\n                  table,\n                  {\n                    name: \"newNameHere\",\n                  }\n                )}`,\n                isEdgeType: true,\n                isPgRowEdgeType: true,\n                nodeType: TableType,\n                pgIntrospection: table,\n              }\n            );\n            const PageInfo = getTypeByName(inflection.builtin(\"PageInfo\"));\n\n            /*const ConnectionType = */\n            newWithHooks(\n              GraphQLObjectType,\n              {\n                description: build.wrapDescription(\n                  `A connection to a list of \\`${tableTypeName}\\` values.`,\n                  \"type\"\n                ),\n                name: inflection.connection(TableType.name),\n                fields: ({ recurseDataGeneratorsForField, fieldWithHooks }) => {\n                  recurseDataGeneratorsForField(\"pageInfo\", true);\n                  return {\n                    nodes: pgField(\n                      build,\n                      fieldWithHooks,\n                      \"nodes\",\n                      {\n                        description: build.wrapDescription(\n                          `A list of \\`${tableTypeName}\\` objects.`,\n                          \"field\"\n                        ),\n                        type: new GraphQLNonNull(\n                          new GraphQLList(\n                            nullableIf(\n                              !pgForbidSetofFunctionsToReturnNull,\n                              TableType\n                            )\n                          )\n                        ),\n                        resolve(data, _args, resolveContext, resolveInfo) {\n                          const safeAlias = getSafeAliasFromResolveInfo(\n                            resolveInfo\n                          );\n                          const liveRecord =\n                            resolveInfo.rootValue &&\n                            resolveInfo.rootValue.liveRecord;\n                          return data.data.map(entry => {\n                            const record = handleNullRow(\n                              entry[safeAlias],\n                              entry[safeAlias].__identifiers\n                            );\n                            if (\n                              record &&\n                              liveRecord &&\n                              primaryKeys &&\n                              entry[safeAlias].__identifiers\n                            ) {\n                              liveRecord(\n                                \"pg\",\n                                table,\n                                entry[safeAlias].__identifiers\n                              );\n                            }\n\n                            return record;\n                          });\n                        },\n                      },\n                      {},\n                      false,\n                      {\n                        withQueryBuilder: queryBuilder => {\n                          if (subscriptions) {\n                            queryBuilder.selectIdentifiers(table);\n                          }\n                        },\n                      }\n                    ),\n                    edges: pgField(\n                      build,\n                      fieldWithHooks,\n                      \"edges\",\n                      {\n                        description: build.wrapDescription(\n                          `A list of edges which contains the \\`${tableTypeName}\\` and cursor to aid in pagination.`,\n                          \"field\"\n                        ),\n                        type: new GraphQLNonNull(\n                          new GraphQLList(new GraphQLNonNull(EdgeType))\n                        ),\n                        resolve(data, _args, _context, resolveInfo) {\n                          const safeAlias = getSafeAliasFromResolveInfo(\n                            resolveInfo\n                          );\n                          return data.data.map(entry => ({\n                            ...entry,\n                            ...entry[safeAlias],\n                          }));\n                        },\n                      },\n                      {},\n                      false,\n                      {\n                        hoistCursor: true,\n                      }\n                    ),\n                    pageInfo: PageInfo && {\n                      description: build.wrapDescription(\n                        \"Information to aid in pagination.\",\n                        \"field\"\n                      ),\n                      type: new GraphQLNonNull(PageInfo),\n                      resolve(data) {\n                        return data;\n                      },\n                    },\n                  };\n                },\n              },\n              {\n                __origin: `Adding table connection type for ${describePgEntity(\n                  table\n                )}. You can rename the table's GraphQL type via a 'Smart Comment':\\n\\n  ${sqlCommentByAddingTags(\n                  table,\n                  {\n                    name: \"newNameHere\",\n                  }\n                )}`,\n                isConnectionType: true,\n                isPgRowConnectionType: true,\n                edgeType: EdgeType,\n                nodeType: TableType,\n                pgIntrospection: table,\n              }\n            );\n          },\n          true\n        );\n        pgRegisterGqlInputTypeByTypeId(\n          tablePgType.id,\n          (_set, modifier) => {\n            // This must come first, it triggers creation of all the types\n            const TableType = pgGetGqlTypeByTypeIdAndModifier(\n              tablePgType.id,\n              null\n            );\n            // This must come after the pgGetGqlTypeByTypeIdAndModifier call\n            if (modifier === \"patch\") {\n              // TODO: v5: move the definition from above down here\n              return TablePatchType;\n            }\n            if (modifier === \"base\") {\n              // TODO: v5: move the definition from above down here\n              return TableBaseInputType;\n            }\n            if (TableType) {\n              return getTypeByName(inflection.inputType(TableType));\n            }\n            return null;\n          },\n          true\n        );\n\n        if (arrayTablePgType) {\n          // Note: these do not return\n          //\n          // `new GraphQLList(new GraphQLNonNull(...))`\n          //\n          // because it's possible to return null entries from postgresql\n          // functions. We should probably add a flag to instead export\n          // the non-null version as that's more typical.\n          pgRegisterGqlTypeByTypeId(\n            arrayTablePgType.id,\n            () => {\n              const TableType = pgGetGqlTypeByTypeIdAndModifier(\n                tablePgType.id,\n                null\n              );\n              return new GraphQLList(TableType);\n            },\n            true\n          );\n          pgRegisterGqlInputTypeByTypeId(\n            arrayTablePgType.id,\n            (_set, modifier) => {\n              const RelevantTableInputType = pgGetGqlInputTypeByTypeIdAndModifier(\n                tablePgType.id,\n                modifier\n              );\n              if (RelevantTableInputType) {\n                return new GraphQLList(RelevantTableInputType);\n              }\n            },\n            true\n          );\n        }\n      });\n      return _;\n    },\n    [\"PgTables\"],\n    [],\n    [\"PgTypes\"]\n  );\n}: Plugin);\n"],"file":"PgTablesPlugin.js"}