{"version":3,"sources":["../../src/plugins/PgRowByUniqueConstraint.js"],"names":["PgRowByUniqueConstraint","builder","subscriptions","hook","fields","build","context","extend","parseResolveInfo","pgGetGqlTypeByTypeIdAndModifier","pgGetGqlInputTypeByTypeIdAndModifier","gql2pg","pgIntrospectionResultsByKind","introspectionResultsByKind","pgSql","sql","graphql","GraphQLNonNull","inflection","pgQueryFromResolveData","queryFromResolveData","pgOmit","omit","pgPrepareAndRun","scope","isRootQuery","fieldWithHooks","class","reduce","memo","table","namespace","TableType","type","id","sqlFullTableName","identifier","name","uniqueConstraints","constraints","filter","con","forEach","constraint","keys","keyAttributes","some","key","every","_","Error","fieldName","rowByUniqueKeys","keysIncludingMeta","map","sqlIdentifier","columnName","column","queryFromResolveDataOptions","useAsterisk","queryFromResolveDataCallback","queryBuilder","args","primaryKeyConstraint","selectIdentifiers","sqlTableAlias","getTableAlias","typeModifier","where","fragment","getDataFromParsedResolveInfoFragment","typeId","InputType","resolve","parent","resolveContext","resolveInfo","pgClient","liveRecord","rootValue","parsedResolveInfoFragment","resolveData","query","undefined","text","values","compile","debugSql","enabled","rows","row","__identifiers","isPgRowByUniqueConstraintField","pgFieldIntrospection"],"mappings":"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","sourcesContent":["// @flow\nimport type { Plugin } from \"graphile-build\";\nimport debugSql from \"./debugSql\";\n\nexport default (async function PgRowByUniqueConstraint(\n  builder,\n  { subscriptions }\n) {\n  builder.hook(\n    \"GraphQLObjectType:fields\",\n    (fields, build, context) => {\n      const {\n        extend,\n        parseResolveInfo,\n        pgGetGqlTypeByTypeIdAndModifier,\n        pgGetGqlInputTypeByTypeIdAndModifier,\n        gql2pg,\n        pgIntrospectionResultsByKind: introspectionResultsByKind,\n        pgSql: sql,\n        graphql: { GraphQLNonNull },\n        inflection,\n        pgQueryFromResolveData: queryFromResolveData,\n        pgOmit: omit,\n        pgPrepareAndRun,\n      } = build;\n      const {\n        scope: { isRootQuery },\n        fieldWithHooks,\n      } = context;\n\n      if (!isRootQuery) {\n        return fields;\n      }\n\n      return extend(\n        fields,\n        introspectionResultsByKind.class.reduce((memo, table) => {\n          // PERFORMANCE: These used to be .filter(...) calls\n          if (!table.namespace) return memo;\n          if (omit(table, \"read\")) return memo;\n\n          const TableType = pgGetGqlTypeByTypeIdAndModifier(\n            table.type.id,\n            null\n          );\n          const sqlFullTableName = sql.identifier(\n            table.namespace.name,\n            table.name\n          );\n          if (TableType) {\n            const uniqueConstraints = table.constraints.filter(\n              con => con.type === \"u\" || con.type === \"p\"\n            );\n            uniqueConstraints.forEach(constraint => {\n              if (omit(constraint, \"read\")) {\n                return;\n              }\n              const keys = constraint.keyAttributes;\n              if (keys.some(key => omit(key, \"read\"))) {\n                return;\n              }\n              if (!keys.every(_ => _)) {\n                throw new Error(\n                  \"Consistency error: could not find an attribute!\"\n                );\n              }\n              const fieldName = inflection.rowByUniqueKeys(\n                keys,\n                table,\n                constraint\n              );\n              const keysIncludingMeta = keys.map(key => ({\n                ...key,\n                sqlIdentifier: sql.identifier(key.name),\n                columnName: inflection.column(key),\n              }));\n              // Precomputation for performance\n              const queryFromResolveDataOptions = {\n                useAsterisk: false, // Because it's only a single relation, no need\n              };\n              const queryFromResolveDataCallback = (queryBuilder, args) => {\n                if (subscriptions && table.primaryKeyConstraint) {\n                  queryBuilder.selectIdentifiers(table);\n                }\n                const sqlTableAlias = queryBuilder.getTableAlias();\n                keysIncludingMeta.forEach(\n                  ({ sqlIdentifier, columnName, type, typeModifier }) => {\n                    queryBuilder.where(\n                      sql.fragment`${sqlTableAlias}.${sqlIdentifier} = ${gql2pg(\n                        args[columnName],\n                        type,\n                        typeModifier\n                      )}`\n                    );\n                  }\n                );\n              };\n\n              memo[fieldName] = fieldWithHooks(\n                fieldName,\n                ({ getDataFromParsedResolveInfoFragment }) => {\n                  return {\n                    type: TableType,\n                    args: keysIncludingMeta.reduce(\n                      (memo, { typeId, typeModifier, columnName, name }) => {\n                        const InputType = pgGetGqlInputTypeByTypeIdAndModifier(\n                          typeId,\n                          typeModifier\n                        );\n                        if (!InputType) {\n                          throw new Error(\n                            `Could not find input type for key '${name}' on type '${TableType.name}'`\n                          );\n                        }\n                        memo[columnName] = {\n                          type: new GraphQLNonNull(InputType),\n                        };\n                        return memo;\n                      },\n                      {}\n                    ),\n                    async resolve(parent, args, resolveContext, resolveInfo) {\n                      const { pgClient } = resolveContext;\n                      const liveRecord =\n                        resolveInfo.rootValue &&\n                        resolveInfo.rootValue.liveRecord;\n                      const parsedResolveInfoFragment = parseResolveInfo(\n                        resolveInfo\n                      );\n                      parsedResolveInfoFragment.args = args; // Allow overriding via makeWrapResolversPlugin\n                      const resolveData = getDataFromParsedResolveInfoFragment(\n                        parsedResolveInfoFragment,\n                        TableType\n                      );\n                      const query = queryFromResolveData(\n                        sqlFullTableName,\n                        undefined,\n                        resolveData,\n                        queryFromResolveDataOptions,\n                        queryBuilder =>\n                          queryFromResolveDataCallback(queryBuilder, args),\n                        resolveContext,\n                        resolveInfo.rootValue\n                      );\n                      const { text, values } = sql.compile(query);\n                      if (debugSql.enabled) debugSql(text);\n                      const {\n                        rows: [row],\n                      } = await pgPrepareAndRun(pgClient, text, values);\n                      if (subscriptions && liveRecord && row) {\n                        liveRecord(\"pg\", table, row.__identifiers);\n                      }\n                      return row;\n                    },\n                  };\n                },\n                {\n                  isPgRowByUniqueConstraintField: true,\n                  pgFieldIntrospection: constraint,\n                }\n              );\n            });\n          }\n          return memo;\n        }, {}),\n        `Adding \"row by unique constraint\" fields to root Query type`\n      );\n    },\n    [\"PgRowByUniqueConstraint\"]\n  );\n}: Plugin);\n"],"file":"PgRowByUniqueConstraint.js"}