{"version":3,"sources":["../src/makeNewBuild.js"],"names":["recurseDataGeneratorsForFieldWarned","isString","str","isDev","indexOf","process","env","NODE_ENV","debug","hashCache","LRU","maxLength","hashFieldAlias","precomputed","get","hash","update","digest","set","getSafeAliasFromAlias","alias","length","startsWith","Error","getSafeAliasFromResolveInfo","resolveInfo","getNameFromType","Type","GraphQLSchema","name","GraphQLInterfaceType","GraphQLObjectType","GraphQLInputObjectType","GraphQLEnumType","GraphQLUnionType","getNamedType","isCompositeType","isAbstractType","graphql","mergeData","data","gen","ReturnType","arg","results","ensureArray","resultIndex","resultCount","result","keys","Object","i","l","k","value","newData","push","knownTypes","knownTypeNames","map","val","Array","isArray","ensureName","_fn","fn","displayName","enabled","console","trace","makeNewBuild","builder","allTypes","Int","GraphQLInt","Float","GraphQLFloat","String","GraphQLString","Boolean","GraphQLBoolean","ID","GraphQLID","allTypesSources","fieldDataGeneratorsByFieldNameByType","Map","fieldArgDataGeneratorsByFieldNameByType","options","graphileBuildVersion","version","versions","require","hasVersion","packageName","range","includePrerelease","packageVersion","semver","satisfies","parseResolveInfo","simplifyParsedResolveInfoFragmentWithType","getAliasFromResolveInfo","resolveAlias","_args","_context","addType","type","origin","newTypeSource","status","currentHookName","oldTypeSource","firstEntityDetails","chalk","magenta","secondEntityDetails","yellow","bold","getTypeByName","typeName","extend","newWithHooks","spec","inScope","performNonEmptyFieldsCheck","scope","warn","fieldDataGeneratorsByFieldName","fieldArgDataGeneratorsByFieldName","newSpec","applyHooks","addDataGeneratorForField","fieldName","Self","recurseDataGeneratorsForField","iKnowWhatIAmDoing","error","parsedResolveInfoFragment","rest","args","fields","StrippedType","argDataGeneratorsForSelfByFieldName","argDataGenerators","genIndex","genCount","local","typeFields","getFields","keyIndex","keyCount","field","gens","commonContext","rawSpec","interfaces","interfacesContext","rawInterfaces","processedFields","fieldsContext","fieldWithHooks","fieldScope","context","addDataGenerator","addArgDataGenerator","getDataFromParsedResolveInfoFragment","dgIndex","dgCount","e","finalSpec","FieldReturnType","returnType","rawFields","fieldsSpec","__origin","fieldSpec","autoField","values","reduce","memo","valueKey","newValue","types","typesContext","rawTypes","_Self","isRootQuery","isProbablyAnEmptyObjectError","message","match","swallowError","scopeByType","fieldDataGeneratorsByType","inflection","pluralize","singularize","singular","upperCamelCase","camelCase","constantCase","builtin","live","coerceToGraphQLName","resultingName","replace","wrapDescription","resolveNode","currentHookEvent","liveCoordinator","LiveCoordinator"],"mappings":"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","sourcesContent":["// @flow\n\nimport * as graphql from \"graphql\";\nimport type {\n  GraphQLNamedType,\n  GraphQLInputField,\n  GraphQLFieldResolver,\n  GraphQLType,\n} from \"graphql\";\nimport {\n  parseResolveInfo,\n  simplifyParsedResolveInfoFragmentWithType,\n  getAliasFromResolveInfo as rawGetAliasFromResolveInfo,\n} from \"graphql-parse-resolve-info\";\nimport debugFactory from \"debug\";\nimport type { ResolveTree } from \"graphql-parse-resolve-info\";\nimport pluralize from \"pluralize\";\nimport LRU from \"@graphile/lru\";\nimport semver from \"semver\";\nimport {\n  upperCamelCase,\n  camelCase,\n  constantCase,\n  wrapDescription,\n} from \"./utils\";\nimport swallowError from \"./swallowError\";\nimport resolveNode from \"./resolveNode\";\nimport { LiveCoordinator } from \"./Live\";\n\nimport type SchemaBuilder, {\n  Build,\n  Context,\n  Scope,\n  DataForType,\n} from \"./SchemaBuilder\";\n\nimport extend, { indent } from \"./extend\";\nimport chalk from \"chalk\";\nimport { createHash } from \"crypto\";\n\nimport { version } from \"../package.json\";\n\nlet recurseDataGeneratorsForFieldWarned = false;\n\nconst isString = str => typeof str === \"string\";\nconst isDev = [\"test\", \"development\"].indexOf(process.env.NODE_ENV) >= 0;\nconst debug = debugFactory(\"graphile-build\");\n\n/*\n * This should be more than enough for normal usage. If you come under a\n * sophisticated attack then the attacker can empty this of useful values (with\n * a lot of work) but because we use SHA1 hashes under the covers the aliases\n * will still be consistent even after the LRU cache is exhausted. And SHA1 can\n * produce half a million hashes per second on my machine, the LRU only gives\n * us a 10x speedup!\n */\nconst hashCache = new LRU({ maxLength: 100000 });\n\n/*\n * This function must never return a string longer than 56 characters.\n *\n * This function must only output alphanumeric and underscore characters.\n *\n * Collisions in SHA1 aren't problematic here (for us; they will be problematic\n * for the user deliberately causing them, but that's their own fault!), so\n * we'll happily take the performance boost over SHA256.\n */\nfunction hashFieldAlias(str) {\n  const precomputed = hashCache.get(str);\n  if (precomputed) return precomputed;\n  const hash = createHash(\"sha1\").update(str).digest(\"hex\");\n  hashCache.set(str, hash);\n  return hash;\n}\n\n/*\n * This function may be replaced at any time, but all versions of it will\n * always return a representation of `alias` (a valid GraphQL identifier)\n * that:\n *\n *   1. won't conflict with normal GraphQL field names\n *   2. won't be over 60 characters long (allows for systems with alias length limits, such as PG)\n *   3. will give the same value when called multiple times within the same GraphQL query\n *   4. matches the regex /^[@!-_A-Za-z0-9]+$/\n *   5. will not be prefixed with `__` (as that will conflict with other Graphile internals)\n *\n * It does not guarantee that this alias will be human readable!\n */\nfunction getSafeAliasFromAlias(alias) {\n  if (alias.length <= 60 && !alias.startsWith(\"@\")) {\n    // Use the `@` to prevent conflicting with normal GraphQL field names, but otherwise let it through verbatim.\n    return `@${alias}`;\n  } else if (alias.length > 1024) {\n    throw new Error(\n      `GraphQL alias '${alias}' is too long, use shorter aliases (max length 1024).`\n    );\n  } else {\n    return `@@${hashFieldAlias(alias)}`;\n  }\n}\n\n/*\n * This provides a \"safe\" version of the alias from ResolveInfo, guaranteed to\n * never be longer than 60 characters. This makes it suitable as a PostgreSQL\n * identifier.\n */\nfunction getSafeAliasFromResolveInfo(resolveInfo) {\n  const alias = rawGetAliasFromResolveInfo(resolveInfo);\n  return getSafeAliasFromAlias(alias);\n}\n\ntype MetaData = {\n  [string]: Array<mixed>,\n};\ntype DataGeneratorFunction = (\n  parsedResolveInfoFragment: ResolveTree,\n  ReturnType: GraphQLType,\n  ...args: Array<mixed>\n) => Array<MetaData>;\n\ntype FieldSpecIsh = {\n  type?: GraphQLType,\n  args?: {},\n  resolve?: GraphQLFieldResolver<*, *>,\n  deprecationReason?: string,\n  description?: ?string,\n};\n\ntype ContextAndGenerators =\n  | Context\n  | {\n      addDataGenerator: DataGeneratorFunction => void,\n      addArgDataGenerator: DataGeneratorFunction => void,\n      getDataFromParsedResolveInfoFragment: (\n        parsedResolveInfoFragment: ResolveTree,\n        Type: GraphQLType\n      ) => DataForType,\n    };\n\nexport type FieldWithHooksFunction = (\n  fieldName: string,\n  spec: FieldSpecIsh | (ContextAndGenerators => FieldSpecIsh),\n  fieldScope?: {}\n) => {};\n\nexport type InputFieldWithHooksFunction = (\n  fieldName: string,\n  spec: GraphQLInputField,\n  fieldScope?: {}\n) => GraphQLInputField;\n\nfunction getNameFromType(Type: GraphQLNamedType | GraphQLSchema) {\n  if (Type instanceof GraphQLSchema) {\n    return \"schema\";\n  } else {\n    return Type.name;\n  }\n}\n\nconst {\n  GraphQLSchema,\n  GraphQLInterfaceType,\n  GraphQLObjectType,\n  GraphQLInputObjectType,\n  GraphQLEnumType,\n  GraphQLUnionType,\n  getNamedType,\n  isCompositeType,\n  isAbstractType,\n} = graphql;\n\nconst mergeData = (\n  data: MetaData,\n  gen: DataGeneratorFunction,\n  ReturnType,\n  arg\n) => {\n  const results: ?Array<MetaData> = ensureArray<MetaData>(\n    gen(arg, ReturnType, data)\n  );\n  if (!results) {\n    return;\n  }\n  for (\n    let resultIndex = 0, resultCount = results.length;\n    resultIndex < resultCount;\n    resultIndex++\n  ) {\n    const result: MetaData = results[resultIndex];\n    const keys = Object.keys(result);\n    for (let i = 0, l = keys.length; i < l; i++) {\n      const k = keys[i];\n      data[k] = data[k] || [];\n      const value: mixed = result[k];\n      const newData: ?Array<mixed> = ensureArray<mixed>(value);\n      if (newData) {\n        data[k].push(...newData);\n      }\n    }\n  }\n};\n\nconst knownTypes = [\n  GraphQLSchema,\n  GraphQLObjectType,\n  GraphQLInputObjectType,\n  GraphQLEnumType,\n  GraphQLUnionType,\n];\nconst knownTypeNames = knownTypes.map(k => k.name);\n\nfunction ensureArray<T>(val: null | T | Array<T>): void | Array<T> {\n  if (val == null) {\n    return;\n  } else if (Array.isArray(val)) {\n    // $FlowFixMe\n    return (val: Array<T>);\n  } else {\n    return ([val]: Array<T>);\n  }\n}\n\n// eslint-disable-next-line no-unused-vars\nlet ensureName = _fn => {};\nif ([\"development\", \"test\"].indexOf(process.env.NODE_ENV) >= 0) {\n  ensureName = fn => {\n    // $FlowFixMe: displayName\n    if (isDev && !fn.displayName && !fn.name && debug.enabled) {\n      // eslint-disable-next-line no-console\n      console.trace(\n        \"WARNING: you've added a function with no name as an argDataGenerator, doing so may make debugging more challenging\"\n      );\n    }\n  };\n}\n\nexport default function makeNewBuild(builder: SchemaBuilder): { ...Build } {\n  const allTypes = {\n    Int: graphql.GraphQLInt,\n    Float: graphql.GraphQLFloat,\n    String: graphql.GraphQLString,\n    Boolean: graphql.GraphQLBoolean,\n    ID: graphql.GraphQLID,\n  };\n  const allTypesSources = {\n    Int: \"GraphQL Built-in\",\n    Float: \"GraphQL Built-in\",\n    String: \"GraphQL Built-in\",\n    Boolean: \"GraphQL Built-in\",\n    ID: \"GraphQL Built-in\",\n  };\n\n  // Every object type gets fieldData associated with each of its\n  // fields.\n\n  // When a field is defined, it may add to this field data.\n\n  // When something resolves referencing this type, the resolver may\n  // request the fieldData, e.g. to perform optimisations.\n\n  // fieldData is an object whose keys are the fields on this\n  // GraphQLObjectType and whose values are an object (whose keys are\n  // arbitrary namespaced keys and whose values are arrays of\n  // information of this kind)\n  const fieldDataGeneratorsByFieldNameByType = new Map();\n  const fieldArgDataGeneratorsByFieldNameByType = new Map();\n\n  return {\n    options: builder.options,\n    graphileBuildVersion: version,\n    versions: {\n      graphql: require(\"graphql/package.json\").version,\n      \"graphile-build\": version,\n    },\n    hasVersion(\n      packageName: string,\n      range: string,\n      options?: { includePrerelease?: boolean } = { includePrerelease: true }\n    ): boolean {\n      const packageVersion = this.versions[packageName];\n      if (!packageVersion) return false;\n      return semver.satisfies(packageVersion, range, options);\n    },\n    graphql,\n    parseResolveInfo,\n    simplifyParsedResolveInfoFragmentWithType,\n    getSafeAliasFromAlias,\n    getAliasFromResolveInfo: getSafeAliasFromResolveInfo, // DEPRECATED: do not use this!\n    getSafeAliasFromResolveInfo,\n    resolveAlias(data, _args, _context, resolveInfo) {\n      const alias = getSafeAliasFromResolveInfo(resolveInfo);\n      return data[alias];\n    },\n    addType(type: GraphQLNamedType, origin?: ?string): void {\n      if (!type.name) {\n        throw new Error(\n          `addType must only be called with named types, try using require('graphql').getNamedType`\n        );\n      }\n      const newTypeSource =\n        origin ||\n        // 'this' is typically only available after the build is finalized\n        (this\n          ? `'addType' call during hook '${this.status.currentHookName}'`\n          : null);\n      if (allTypes[type.name]) {\n        if (allTypes[type.name] !== type) {\n          const oldTypeSource = allTypesSources[type.name];\n          const firstEntityDetails = !oldTypeSource\n            ? \"The first type was registered from an unknown origin.\"\n            : `The first entity was:\\n\\n${indent(\n                chalk.magenta(oldTypeSource)\n              )}`;\n          const secondEntityDetails = !newTypeSource\n            ? \"The second type was registered from an unknown origin.\"\n            : `The second entity was:\\n\\n${indent(\n                chalk.yellow(newTypeSource)\n              )}`;\n          throw new Error(\n            `A type naming conflict has occurred - two entities have tried to define the same type '${chalk.bold(\n              type.name\n            )}'.\\n\\n${indent(firstEntityDetails)}\\n\\n${indent(\n              secondEntityDetails\n            )}`\n          );\n        }\n      } else {\n        allTypes[type.name] = type;\n        allTypesSources[type.name] = newTypeSource;\n      }\n    },\n    getTypeByName(typeName) {\n      return allTypes[typeName];\n    },\n    extend,\n    newWithHooks<T: GraphQLNamedType | GraphQLSchema, ConfigType: *>(\n      Type: Class<T>,\n      spec: ConfigType,\n      inScope: Scope,\n      performNonEmptyFieldsCheck = false\n    ): ?T {\n      const scope = inScope || {};\n      if (!inScope) {\n        // eslint-disable-next-line no-console\n        console.warn(\n          `No scope was provided to new ${Type.name}[name=${spec.name}], it's highly recommended that you add a scope so other hooks can easily reference your object - please check usage of 'newWithHooks'. To mute this message, just pass an empty object.`\n        );\n      }\n      if (!Type) {\n        throw new Error(\"No type specified!\");\n      }\n      if (!this.newWithHooks) {\n        throw new Error(\n          \"Please do not generate the schema during the build building phase, use 'init' instead\"\n        );\n      }\n      const fieldDataGeneratorsByFieldName = {};\n      const fieldArgDataGeneratorsByFieldName = {};\n      let newSpec = spec;\n      if (\n        knownTypes.indexOf(Type) === -1 &&\n        knownTypeNames.indexOf(Type.name) >= 0\n      ) {\n        throw new Error(\n          `GraphQL conflict for '${Type.name}' detected! Multiple versions of graphql exist in your node_modules?`\n        );\n      }\n      if (Type === GraphQLSchema) {\n        newSpec = builder.applyHooks(this, \"GraphQLSchema\", newSpec, {\n          type: \"GraphQLSchema\",\n          scope,\n        });\n      } else if (Type === GraphQLObjectType) {\n        const addDataGeneratorForField = (\n          fieldName,\n          fn: DataGeneratorFunction\n        ) => {\n          // $FlowFixMe: displayName\n          fn.displayName =\n            // $FlowFixMe: displayName\n            fn.displayName ||\n            `${getNameFromType(Self)}:${fieldName}[${fn.name || \"anonymous\"}]`;\n          fieldDataGeneratorsByFieldName[fieldName] =\n            fieldDataGeneratorsByFieldName[fieldName] || [];\n          fieldDataGeneratorsByFieldName[fieldName].push(fn);\n        };\n        const recurseDataGeneratorsForField = (\n          fieldName,\n          iKnowWhatIAmDoing\n        ) => {\n          /*\n           * Recursing data generators is not safe in general; however there\n           * are certain exceptions - for example when you know there are no\n           * \"dynamic\" data generator fields - e.g. where the GraphQL alias is\n           * not used at all. In PostGraphile the only case of this is the\n           * PageInfo object as none of the fields accept arguments, and they\n           * do not rely on the GraphQL query alias to store the result.\n           */\n          if (!iKnowWhatIAmDoing && !recurseDataGeneratorsForFieldWarned) {\n            recurseDataGeneratorsForFieldWarned = true;\n            // eslint-disable-next-line no-console\n            console.error(\n              \"Use of `recurseDataGeneratorsForField` is NOT SAFE. e.g. `{n1: node { a: field1 }, n2: node { a: field2 } }` cannot resolve correctly.\"\n            );\n          }\n          const fn = (parsedResolveInfoFragment, ReturnType, ...rest) => {\n            const { args } = parsedResolveInfoFragment;\n            const { fields } = this.simplifyParsedResolveInfoFragmentWithType(\n              parsedResolveInfoFragment,\n              ReturnType\n            );\n            const results = [];\n            const StrippedType: GraphQLNamedType = getNamedType(ReturnType);\n            const fieldDataGeneratorsByFieldName = fieldDataGeneratorsByFieldNameByType.get(\n              StrippedType\n            );\n            const argDataGeneratorsForSelfByFieldName = fieldArgDataGeneratorsByFieldNameByType.get(\n              Self\n            );\n            if (argDataGeneratorsForSelfByFieldName) {\n              const argDataGenerators =\n                argDataGeneratorsForSelfByFieldName[fieldName];\n              for (\n                let genIndex = 0, genCount = argDataGenerators.length;\n                genIndex < genCount;\n                genIndex++\n              ) {\n                const gen = argDataGenerators[genIndex];\n                const local = ensureArray(gen(args, ReturnType, ...rest));\n                if (local) {\n                  results.push(...local);\n                }\n              }\n            }\n            if (\n              fieldDataGeneratorsByFieldName &&\n              isCompositeType(StrippedType) &&\n              !isAbstractType(StrippedType)\n            ) {\n              const typeFields = StrippedType.getFields();\n              const keys = Object.keys(fields);\n              for (\n                let keyIndex = 0, keyCount = keys.length;\n                keyIndex < keyCount;\n                keyIndex++\n              ) {\n                const alias = keys[keyIndex];\n                const field = fields[alias];\n                // Run generators with `field` as the `parsedResolveInfoFragment`, pushing results to `results`\n                const gens = fieldDataGeneratorsByFieldName[field.name];\n                if (gens) {\n                  for (\n                    let genIndex = 0, genCount = gens.length;\n                    genIndex < genCount;\n                    genIndex++\n                  ) {\n                    const gen = gens[genIndex];\n                    const local = ensureArray(\n                      gen(field, typeFields[field.name].type, ...rest)\n                    );\n                    if (local) {\n                      results.push(...local);\n                    }\n                  }\n                }\n              }\n            }\n            return results;\n          };\n          fn.displayName = `recurseDataGeneratorsForField(${getNameFromType(\n            Self\n          )}:${fieldName})`;\n          addDataGeneratorForField(fieldName, fn);\n          // get type from field, get\n        };\n\n        const commonContext = {\n          type: \"GraphQLObjectType\",\n          scope,\n        };\n        newSpec = builder.applyHooks(\n          this,\n          \"GraphQLObjectType\",\n          newSpec,\n          {\n            ...commonContext,\n            addDataGeneratorForField,\n            recurseDataGeneratorsForField,\n          },\n          `|${newSpec.name}`\n        );\n\n        const rawSpec = newSpec;\n        newSpec = {\n          ...newSpec,\n          interfaces: () => {\n            const interfacesContext = {\n              ...commonContext,\n              Self,\n              GraphQLObjectType: rawSpec,\n            };\n            let rawInterfaces = rawSpec.interfaces || [];\n            if (typeof rawInterfaces === \"function\") {\n              rawInterfaces = rawInterfaces(interfacesContext);\n            }\n            return builder.applyHooks(\n              this,\n              \"GraphQLObjectType:interfaces\",\n              rawInterfaces,\n              interfacesContext,\n              `|${getNameFromType(Self)}`\n            );\n          },\n          fields: () => {\n            const processedFields = [];\n            const fieldsContext = {\n              ...commonContext,\n              addDataGeneratorForField,\n              recurseDataGeneratorsForField,\n              Self,\n              GraphQLObjectType: rawSpec,\n              fieldWithHooks: ((fieldName, spec, fieldScope) => {\n                if (!isString(fieldName)) {\n                  throw new Error(\n                    \"It looks like you forgot to pass the fieldName to `fieldWithHooks`, we're sorry this is currently necessary.\"\n                  );\n                }\n                if (!fieldScope) {\n                  throw new Error(\n                    \"All calls to `fieldWithHooks` must specify a `fieldScope` \" +\n                      \"argument that gives additional context about the field so \" +\n                      \"that further plugins may more easily understand the field. \" +\n                      \"Keys within this object should contain the phrase 'field' \" +\n                      \"since they will be merged into the parent objects scope and \" +\n                      \"are not allowed to clash. If you really have no additional \" +\n                      \"information to give, please just pass `{}`.\"\n                  );\n                }\n\n                const argDataGenerators = [];\n                fieldArgDataGeneratorsByFieldName[\n                  fieldName\n                ] = argDataGenerators;\n\n                let newSpec = spec;\n                const context = {\n                  ...commonContext,\n                  Self,\n                  addDataGenerator(fn) {\n                    return addDataGeneratorForField(fieldName, fn);\n                  },\n                  addArgDataGenerator(fn) {\n                    ensureName(fn);\n                    argDataGenerators.push(fn);\n                  },\n                  getDataFromParsedResolveInfoFragment: (\n                    parsedResolveInfoFragment,\n                    ReturnType\n                  ): DataForType => {\n                    const Type: GraphQLNamedType = getNamedType(ReturnType);\n                    const data = {};\n\n                    const {\n                      fields,\n                      args,\n                    } = this.simplifyParsedResolveInfoFragmentWithType(\n                      parsedResolveInfoFragment,\n                      ReturnType\n                    );\n\n                    // Args -> argDataGenerators\n                    for (\n                      let dgIndex = 0, dgCount = argDataGenerators.length;\n                      dgIndex < dgCount;\n                      dgIndex++\n                    ) {\n                      const gen = argDataGenerators[dgIndex];\n                      try {\n                        mergeData(data, gen, ReturnType, args);\n                      } catch (e) {\n                        debug(\n                          \"Failed to execute argDataGenerator '%s' on %s of %s\",\n                          gen.displayName || gen.name || \"anonymous\",\n                          fieldName,\n                          getNameFromType(Self)\n                        );\n                        throw e;\n                      }\n                    }\n\n                    // finalSpec.type -> fieldData\n                    if (!finalSpec) {\n                      throw new Error(\n                        \"It's too early to call this! Call from within resolve\"\n                      );\n                    }\n                    const fieldDataGeneratorsByFieldName = fieldDataGeneratorsByFieldNameByType.get(\n                      Type\n                    );\n                    if (\n                      fieldDataGeneratorsByFieldName &&\n                      isCompositeType(Type) &&\n                      !isAbstractType(Type)\n                    ) {\n                      const typeFields = Type.getFields();\n                      const keys = Object.keys(fields);\n                      for (\n                        let keyIndex = 0, keyCount = keys.length;\n                        keyIndex < keyCount;\n                        keyIndex++\n                      ) {\n                        const alias = keys[keyIndex];\n                        const field = fields[alias];\n                        const gens = fieldDataGeneratorsByFieldName[field.name];\n                        if (gens) {\n                          const FieldReturnType = typeFields[field.name].type;\n                          for (let i = 0, l = gens.length; i < l; i++) {\n                            mergeData(data, gens[i], FieldReturnType, field);\n                          }\n                        }\n                      }\n                    }\n                    return data;\n                  },\n                  scope: extend(\n                    extend(\n                      { ...scope },\n                      {\n                        fieldName,\n                      },\n                      `Within context for GraphQLObjectType '${rawSpec.name}'`\n                    ),\n                    fieldScope,\n                    `Extending scope for field '${fieldName}' within context for GraphQLObjectType '${rawSpec.name}'`\n                  ),\n                };\n                if (typeof newSpec === \"function\") {\n                  newSpec = newSpec(context);\n                }\n                newSpec = builder.applyHooks(\n                  this,\n                  \"GraphQLObjectType:fields:field\",\n                  newSpec,\n                  context,\n                  `|${getNameFromType(Self)}.fields.${fieldName}`\n                );\n                newSpec.args = newSpec.args || {};\n                newSpec = {\n                  ...newSpec,\n                  args: builder.applyHooks(\n                    this,\n                    \"GraphQLObjectType:fields:field:args\",\n                    newSpec.args,\n                    {\n                      ...context,\n                      field: newSpec,\n                      returnType: newSpec.type,\n                    },\n                    `|${getNameFromType(Self)}.fields.${fieldName}`\n                  ),\n                };\n                const finalSpec = newSpec;\n                processedFields.push(finalSpec);\n                return finalSpec;\n              }: FieldWithHooksFunction),\n            };\n            let rawFields = rawSpec.fields || {};\n            if (typeof rawFields === \"function\") {\n              rawFields = rawFields(fieldsContext);\n            }\n            const fieldsSpec = builder.applyHooks(\n              this,\n              \"GraphQLObjectType:fields\",\n              this.extend(\n                {},\n                rawFields,\n                `Default field included in newWithHooks call for '${\n                  rawSpec.name\n                }'. ${inScope.__origin || \"\"}`\n              ),\n              fieldsContext,\n              `|${rawSpec.name}`\n            );\n            // Finally, check through all the fields that they've all been processed; any that have not we should do so now.\n            for (const fieldName in fieldsSpec) {\n              const fieldSpec = fieldsSpec[fieldName];\n              if (processedFields.indexOf(fieldSpec) < 0) {\n                // We've not processed this yet; process it now!\n                fieldsSpec[fieldName] = fieldsContext.fieldWithHooks(\n                  fieldName,\n                  fieldSpec,\n                  {\n                    autoField: true, // We don't have any additional information\n                  }\n                );\n              }\n            }\n            return fieldsSpec;\n          },\n        };\n      } else if (Type === GraphQLInputObjectType) {\n        const commonContext = {\n          type: \"GraphQLInputObjectType\",\n          scope,\n        };\n        newSpec = builder.applyHooks(\n          this,\n          \"GraphQLInputObjectType\",\n          newSpec,\n          commonContext,\n          `|${newSpec.name}`\n        );\n        newSpec.fields = newSpec.fields || {};\n\n        const rawSpec = newSpec;\n        newSpec = {\n          ...newSpec,\n          fields: () => {\n            const processedFields = [];\n            const fieldsContext = {\n              ...commonContext,\n              Self,\n              GraphQLInputObjectType: rawSpec,\n              fieldWithHooks: ((fieldName, spec, fieldScope = {}) => {\n                if (!isString(fieldName)) {\n                  throw new Error(\n                    \"It looks like you forgot to pass the fieldName to `fieldWithHooks`, we're sorry this is currently necessary.\"\n                  );\n                }\n                const context = {\n                  ...commonContext,\n                  Self,\n                  scope: extend(\n                    extend(\n                      { ...scope },\n                      {\n                        fieldName,\n                      },\n                      `Within context for GraphQLInputObjectType '${rawSpec.name}'`\n                    ),\n                    fieldScope,\n                    `Extending scope for field '${fieldName}' within context for GraphQLInputObjectType '${rawSpec.name}'`\n                  ),\n                };\n                let newSpec = spec;\n                if (typeof newSpec === \"function\") {\n                  newSpec = newSpec(context);\n                }\n                newSpec = builder.applyHooks(\n                  this,\n                  \"GraphQLInputObjectType:fields:field\",\n                  newSpec,\n                  context,\n                  `|${getNameFromType(Self)}.fields.${fieldName}`\n                );\n                const finalSpec = newSpec;\n                processedFields.push(finalSpec);\n                return finalSpec;\n              }: InputFieldWithHooksFunction),\n            };\n            let rawFields = rawSpec.fields;\n            if (typeof rawFields === \"function\") {\n              rawFields = rawFields(fieldsContext);\n            }\n            const fieldsSpec = builder.applyHooks(\n              this,\n              \"GraphQLInputObjectType:fields\",\n              this.extend(\n                {},\n                rawFields,\n                `Default field included in newWithHooks call for '${\n                  rawSpec.name\n                }'. ${inScope.__origin || \"\"}`\n              ),\n              fieldsContext,\n              `|${getNameFromType(Self)}`\n            );\n            // Finally, check through all the fields that they've all been processed; any that have not we should do so now.\n            for (const fieldName in fieldsSpec) {\n              const fieldSpec = fieldsSpec[fieldName];\n              if (processedFields.indexOf(fieldSpec) < 0) {\n                // We've not processed this yet; process it now!\n                fieldsSpec[fieldName] = fieldsContext.fieldWithHooks(\n                  fieldName,\n                  fieldSpec,\n                  {\n                    autoField: true, // We don't have any additional information\n                  }\n                );\n              }\n            }\n            return fieldsSpec;\n          },\n        };\n      } else if (Type === GraphQLEnumType) {\n        const commonContext = {\n          type: \"GraphQLEnumType\",\n          scope,\n        };\n        newSpec = builder.applyHooks(\n          this,\n          \"GraphQLEnumType\",\n          newSpec,\n          commonContext,\n          `|${newSpec.name}`\n        );\n\n        newSpec.values = builder.applyHooks(\n          this,\n          \"GraphQLEnumType:values\",\n          newSpec.values,\n          commonContext,\n          `|${newSpec.name}`\n        );\n        const values = newSpec.values;\n        newSpec.values = Object.keys(values).reduce((memo, valueKey) => {\n          const value = values[valueKey];\n          const newValue = builder.applyHooks(\n            this,\n            \"GraphQLEnumType:values:value\",\n            value,\n            commonContext,\n            `|${newSpec.name}|${valueKey}`\n          );\n          memo[valueKey] = newValue;\n          return memo;\n        }, {});\n      } else if (Type === GraphQLUnionType) {\n        const commonContext = {\n          type: \"GraphQLUnionType\",\n          scope,\n        };\n        newSpec = builder.applyHooks(\n          this,\n          \"GraphQLUnionType\",\n          newSpec,\n          { ...commonContext },\n          `|${newSpec.name}`\n        );\n\n        const rawSpec = newSpec;\n        newSpec = {\n          ...newSpec,\n          types: () => {\n            const typesContext = {\n              ...commonContext,\n              Self,\n              GraphQLUnionType: rawSpec,\n            };\n            let rawTypes = rawSpec.types || [];\n            if (typeof rawTypes === \"function\") {\n              rawTypes = rawTypes(typesContext);\n            }\n            return builder.applyHooks(\n              this,\n              \"GraphQLUnionType:types\",\n              rawTypes,\n              typesContext,\n              `|${getNameFromType(Self)}`\n            );\n          },\n        };\n      } else if (Type === GraphQLInterfaceType) {\n        const commonContext = {\n          type: \"GraphQLInterfaceType\",\n          scope,\n        };\n        newSpec = builder.applyHooks(\n          this,\n          \"GraphQLInterfaceType\",\n          newSpec,\n          commonContext,\n          `|${newSpec.name}`\n        );\n\n        const rawSpec = newSpec;\n        newSpec = {\n          ...newSpec,\n          fields: () => {\n            const processedFields = [];\n            const fieldsContext = {\n              ...commonContext,\n              Self,\n              GraphQLInterfaceType: rawSpec,\n              fieldWithHooks: ((fieldName, spec, fieldScope) => {\n                if (!isString(fieldName)) {\n                  throw new Error(\n                    \"It looks like you forgot to pass the fieldName to `fieldWithHooks`, we're sorry this is currently necessary.\"\n                  );\n                }\n                if (!fieldScope) {\n                  throw new Error(\n                    \"All calls to `fieldWithHooks` must specify a `fieldScope` \" +\n                      \"argument that gives additional context about the field so \" +\n                      \"that further plugins may more easily understand the field. \" +\n                      \"Keys within this object should contain the phrase 'field' \" +\n                      \"since they will be merged into the parent objects scope and \" +\n                      \"are not allowed to clash. If you really have no additional \" +\n                      \"information to give, please just pass `{}`.\"\n                  );\n                }\n\n                let newSpec = spec;\n                const context = {\n                  ...commonContext,\n                  Self,\n                  scope: extend(\n                    extend(\n                      { ...scope },\n                      {\n                        fieldName,\n                      },\n                      `Within context for GraphQLInterfaceType '${rawSpec.name}'`\n                    ),\n                    fieldScope,\n                    `Extending scope for field '${fieldName}' within context for GraphQLInterfaceType '${rawSpec.name}'`\n                  ),\n                };\n                if (typeof newSpec === \"function\") {\n                  newSpec = newSpec(context);\n                }\n                newSpec = builder.applyHooks(\n                  this,\n                  \"GraphQLInterfaceType:fields:field\",\n                  newSpec,\n                  context,\n                  `|${getNameFromType(Self)}.fields.${fieldName}`\n                );\n                newSpec.args = newSpec.args || {};\n                newSpec = {\n                  ...newSpec,\n                  args: builder.applyHooks(\n                    this,\n                    \"GraphQLInterfaceType:fields:field:args\",\n                    newSpec.args,\n                    {\n                      ...context,\n                      field: newSpec,\n                      returnType: newSpec.type,\n                    },\n                    `|${getNameFromType(Self)}.fields.${fieldName}`\n                  ),\n                };\n                const finalSpec = newSpec;\n                processedFields.push(finalSpec);\n                return finalSpec;\n              }: FieldWithHooksFunction),\n            };\n            let rawFields = rawSpec.fields || {};\n            if (typeof rawFields === \"function\") {\n              rawFields = rawFields(fieldsContext);\n            }\n            const fieldsSpec = builder.applyHooks(\n              this,\n              \"GraphQLInterfaceType:fields\",\n              this.extend(\n                {},\n                rawFields,\n                `Default field included in newWithHooks call for '${\n                  rawSpec.name\n                }'. ${inScope.__origin || \"\"}`\n              ),\n              fieldsContext,\n              `|${rawSpec.name}`\n            );\n            // Finally, check through all the fields that they've all been processed; any that have not we should do so now.\n            for (const fieldName in fieldsSpec) {\n              const fieldSpec = fieldsSpec[fieldName];\n              if (processedFields.indexOf(fieldSpec) < 0) {\n                // We've not processed this yet; process it now!\n                fieldsSpec[fieldName] = fieldsContext.fieldWithHooks(\n                  fieldName,\n                  fieldSpec,\n                  {\n                    autoField: true, // We don't have any additional information\n                  }\n                );\n              }\n            }\n            return fieldsSpec;\n          },\n        };\n      }\n\n      const finalSpec: ConfigType = newSpec;\n\n      const Self: T = new Type(finalSpec);\n      if (!(Self instanceof GraphQLSchema) && performNonEmptyFieldsCheck) {\n        try {\n          if (\n            Self instanceof GraphQLInterfaceType ||\n            Self instanceof GraphQLObjectType ||\n            Self instanceof GraphQLInputObjectType\n          ) {\n            const _Self:\n              | GraphQLInterfaceType\n              | GraphQLInputObjectType\n              | GraphQLObjectType = Self;\n            if (typeof _Self.getFields === \"function\") {\n              const fields = _Self.getFields();\n              if (Object.keys(fields).length === 0) {\n                // We require there's at least one field on GraphQLObjectType and GraphQLInputObjectType records\n                return null;\n              }\n            }\n          }\n        } catch (e) {\n          // This is the error we're expecting to handle:\n          // https://github.com/graphql/graphql-js/blob/831598ba76f015078ecb6c5c1fbaf133302f3f8e/src/type/definition.js#L526-L531\n          if (inScope && inScope.isRootQuery) {\n            throw e;\n          }\n          const isProbablyAnEmptyObjectError = !!e.message.match(\n            /function which returns such an object/\n          );\n          if (!isProbablyAnEmptyObjectError) {\n            this.swallowError(e);\n          }\n          return null;\n        }\n      }\n\n      this.scopeByType.set(Self, scope);\n      if (finalSpec.name) {\n        this.addType(\n          Self,\n          scope.__origin ||\n            (this\n              ? `'newWithHooks' call during hook '${this.status.currentHookName}'`\n              : null)\n        );\n      }\n      fieldDataGeneratorsByFieldNameByType.set(\n        Self,\n        fieldDataGeneratorsByFieldName\n      );\n      fieldArgDataGeneratorsByFieldNameByType.set(\n        Self,\n        fieldArgDataGeneratorsByFieldName\n      );\n      return Self;\n    },\n    fieldDataGeneratorsByType: fieldDataGeneratorsByFieldNameByType, // @deprecated\n    fieldDataGeneratorsByFieldNameByType,\n    fieldArgDataGeneratorsByFieldNameByType,\n    inflection: {\n      pluralize,\n      singularize: pluralize.singular,\n      upperCamelCase,\n      camelCase,\n      constantCase,\n\n      // Built-in names (allows you to override these in the output schema)\n      builtin: name => {\n        /*\n         * e.g.:\n         *\n         * graphile-build:\n         *\n         * - Query\n         * - Mutation\n         * - Subscription\n         * - Node\n         * - PageInfo\n         *\n         * graphile-build-pg:\n         *\n         * - Interval\n         * - BigInt\n         * - BigFloat\n         * - BitString\n         * - Point\n         * - Date\n         * - Datetime\n         * - Time\n         * - JSON\n         * - UUID\n         * - InternetAddress\n         *\n         * Other plugins may add their own builtins too; try and avoid conflicts!\n         */\n        return name;\n      },\n\n      // When converting a query field to a subscription (live query) field, this allows you to rename it\n      live: name => name,\n\n      // Try and make something a valid GraphQL 'Name'\n      coerceToGraphQLName: (name: string) => {\n        let resultingName = name;\n\n        /*\n         * Name is defined in GraphQL to match this regexp:\n         *\n         * /^[_A-Za-z][_0-9A-Za-z]*$/\n         *\n         * See: https://graphql.github.io/graphql-spec/June2018/#sec-Appendix-Grammar-Summary.Lexical-Tokens\n         *\n         * So if our 'name' starts with a digit, we must prefix it with\n         * something. We'll just use an underscore.\n         */\n        if (resultingName.match(/^[0-9]/)) {\n          resultingName = \"_\" + resultingName;\n        }\n\n        /*\n         * Fields beginning with two underscores are reserved by the GraphQL\n         * introspection systems, trim to just one.\n         */\n        resultingName = resultingName.replace(/^__+/g, \"_\");\n\n        return resultingName;\n      },\n    },\n    wrapDescription,\n    swallowError,\n    // resolveNode: EXPERIMENTAL, API might change!\n    resolveNode,\n    status: {\n      currentHookName: null,\n      currentHookEvent: null,\n    },\n    liveCoordinator: new LiveCoordinator(),\n    scopeByType: new Map(),\n  };\n}\n"],"file":"makeNewBuild.js"}