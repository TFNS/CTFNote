"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.watchPostGraphQLSchema = exports.createPostGraphQLSchema = exports.postGraphQLClassicIdsInflection = exports.postGraphQLInflection = exports.postGraphQLClassicIdsOverrides = exports.postGraphQLBaseOverrides = exports.watchPostGraphileSchema = exports.createPostGraphileSchema = exports.getPostGraphileBuilder = exports.PostGraphileClassicIdsInflectionPlugin = exports.PostGraphileInflectionPlugin = exports.postGraphileClassicIdsInflection = exports.postGraphileInflection = exports.postGraphileClassicIdsOverrides = exports.postGraphileBaseOverrides = exports.inflections = exports.formatSQLForDebugging = exports.SchemaBuilder = void 0;
// @flow
const fs = require("fs");
const graphile_build_1 = require("graphile-build");
Object.defineProperty(exports, "SchemaBuilder", { enumerable: true, get: function () { return graphile_build_1.SchemaBuilder; } });
const graphile_build_pg_1 = require("graphile-build-pg");
Object.defineProperty(exports, "inflections", { enumerable: true, get: function () { return graphile_build_pg_1.inflections; } });
Object.defineProperty(exports, "formatSQLForDebugging", { enumerable: true, get: function () { return graphile_build_pg_1.formatSQLForDebugging; } });
const ensureValidPlugins = (name, arr) => {
    if (!Array.isArray(arr)) {
        throw new Error(`Option '${name}' should be an array`);
    }
    for (let i = 0, l = arr.length; i < l; i++) {
        const fn = arr[i];
        if (typeof fn !== "function") {
            throw new Error(`Option '${name}' should be an array of functions, found '${fn == null ? String(fn) : typeof fn}' at index ${i}`);
        }
    }
};
exports.postGraphileBaseOverrides = {
    enumName(value) {
        return graphile_build_pg_1.inflections.defaultUtils.constantCase(graphile_build_pg_1.inflections.defaultInflection.enumName(value));
    },
};
exports.postGraphileClassicIdsOverrides = {
    column(name, _table, _schema) {
        return name === "id" ? "rowId" : graphile_build_pg_1.inflections.defaultUtils.camelCase(name);
    },
};
exports.postGraphileInflection = graphile_build_pg_1.inflections.newInflector(exports.postGraphileBaseOverrides);
exports.postGraphileClassicIdsInflection = graphile_build_pg_1.inflections.newInflector(Object.assign(Object.assign({}, exports.postGraphileBaseOverrides), exports.postGraphileClassicIdsOverrides));
/*
 * ABOVE HERE IS DEPRECATED.
 */
exports.PostGraphileInflectionPlugin = function (builder) {
    builder.hook("inflection", (inflection) => {
        const previous = inflection.enumName;
        // Overwrite directly so that we don't lose the 'extend' hints
        Object.assign(inflection, {
            enumName(value) {
                return this.constantCase(previous.call(this, value));
            },
        });
        return inflection;
    });
};
exports.PostGraphileClassicIdsInflectionPlugin = function (builder) {
    builder.hook("inflection", (inflection) => {
        const previous = inflection._columnName;
        // Overwrite directly so that we don't lose the 'extend' hints
        Object.assign(inflection, {
            _columnName(attr, options) {
                const previousValue = previous.call(this, attr, options);
                return (options && options.skipRowId) || previousValue !== "id"
                    ? previousValue
                    : this.camelCase("rowId");
            },
        });
        return inflection;
    });
};
const awaitKeys = async (obj) => {
    const result = {};
    for (const k in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, k)) {
            result[k] = await obj[k];
        }
    }
    return result;
};
exports.getPostGraphileBuilder = async (pgConfig, schemas, options = {}) => {
    // @ts-ignore Deprecated, doesn't exist on types, checking in JS only
    if (options.inflector) {
        throw new Error("Passing an inflector via PostGraphile options was deprecated in v4.0.0-beta.7; instead please write an inflector plugin: https://www.graphile.org/postgraphile/inflection/");
    }
    const { dynamicJson, classicIds, nodeIdFieldName, replaceAllPlugins, appendPlugins = [], prependPlugins = [], skipPlugins = [], jwtPgTypeIdentifier, jwtSecret, jwtSignOptions, disableDefaultMutations, graphileBuildOptions, graphqlBuildOptions, // DEPRECATED!
    inflector, // NO LONGER SUPPORTED!
    pgColumnFilter, viewUniqueKey, enableTags = true, readCache, writeCache, setWriteCacheCallback, legacyRelations = "deprecated", // TODO:v5: Change to 'omit' in v5
    setofFunctionsContainNulls = true, legacyJsonUuid = false, simpleCollections = "omit", includeExtensionResources = false, ignoreRBAC = true, // TODO:v5: Change to 'false' in v5
    legacyFunctionsOnly = false, // TODO:v5: Remove in v5
    ignoreIndexes = true, // TODO:v5: Change to 'false' in v5
    hideIndexWarnings = false, subscriptions: inSubscriptions = false, // TODO:v5: Change to 'true' in v5
    live = false, ownerConnectionString, } = options;
    const subscriptions = live || inSubscriptions;
    if (legacyRelations &&
        ["only", "deprecated", "omit"].indexOf(legacyRelations) < 0) {
        throw new Error("Invalid configuration for legacy relations: " +
            JSON.stringify(legacyRelations));
    }
    if (simpleCollections &&
        ["only", "both", "omit"].indexOf(simpleCollections) < 0) {
        throw new Error("Invalid configuration for simple collections: " +
            JSON.stringify(simpleCollections));
    }
    if (replaceAllPlugins) {
        ensureValidPlugins("replaceAllPlugins", replaceAllPlugins);
        if ((prependPlugins && prependPlugins.length) ||
            (appendPlugins && appendPlugins.length)) {
            throw new Error("When using 'replaceAllPlugins' you must not specify 'appendPlugins'/'prependPlugins'");
        }
    }
    if (readCache && writeCache) {
        throw new Error("Use `readCache` or `writeCache` - not both.");
    }
    let persistentMemoizeWithKey; // NOT null, otherwise it won't default correctly.
    let memoizeCache = {};
    if (readCache) {
        if (typeof readCache === "string") {
            const cacheString = await new Promise((resolve, reject) => {
                fs.readFile(readCache, "utf8", (err, data) => {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve(data);
                    }
                });
            });
            try {
                memoizeCache = JSON.parse(cacheString);
            }
            catch (e) {
                throw new Error(`Failed to parse cache file '${readCache}', perhaps it is corrupted? ${e}`);
            }
        }
        else if (typeof readCache === "object" && !Array.isArray(readCache)) {
            memoizeCache = readCache;
        }
        else {
            throw new Error(`'readCache' not understood; expected string or object, but received '${Array.isArray(readCache) ? "array" : typeof readCache}'`);
        }
    }
    if (readCache || writeCache) {
        persistentMemoizeWithKey = (key, fn) => {
            if (!(key in memoizeCache)) {
                if (readCache) {
                    throw new Error(`Expected cache to contain key: ${key}`);
                }
                memoizeCache[key] = fn();
                if (memoizeCache[key] === undefined) {
                    throw new Error(`Cannot memoize 'undefined' - use 'null' instead`);
                }
            }
            return memoizeCache[key];
        };
    }
    if (writeCache && setWriteCacheCallback) {
        setWriteCacheCallback(() => awaitKeys(memoizeCache).then(obj => new Promise((resolve, reject) => {
            fs.writeFile(writeCache, JSON.stringify(obj), err => {
                memoizeCache = {};
                if (err) {
                    reject(err);
                }
                else {
                    resolve();
                }
            });
        })));
    }
    else if (writeCache) {
        throw new Error("Cannot write cache without 'setWriteCacheCallback'");
    }
    else if (setWriteCacheCallback) {
        setWriteCacheCallback(() => Promise.resolve());
    }
    ensureValidPlugins("prependPlugins", prependPlugins);
    ensureValidPlugins("appendPlugins", appendPlugins);
    ensureValidPlugins("skipPlugins", skipPlugins);
    if (inflector) {
        throw new Error("Custom inflector arguments are not supported, please use the inflector plugin API instead: https://www.graphile.org/postgraphile/inflection/");
    }
    const inflectionOverridePlugins = classicIds
        ? [exports.PostGraphileInflectionPlugin, exports.PostGraphileClassicIdsInflectionPlugin]
        : [exports.PostGraphileInflectionPlugin];
    const basePluginList = replaceAllPlugins
        ? [
            ...prependPlugins,
            ...replaceAllPlugins,
            ...inflectionOverridePlugins,
            ...appendPlugins,
        ]
        : [
            ...prependPlugins,
            ...graphile_build_1.defaultPlugins,
            ...graphile_build_pg_1.defaultPlugins,
            ...inflectionOverridePlugins,
            ...appendPlugins,
        ];
    const invalidSkipPlugins = skipPlugins.filter(pluginToSkip => basePluginList.indexOf(pluginToSkip) < 0);
    if (invalidSkipPlugins.length) {
        function getFunctionName(fn) {
            return fn.displayName || fn.name || String(fn);
        }
        throw new Error(`You tried to skip plugins that would never have been loaded anyway. Perhaps you've made a mistake in your skipPlugins list, or have sourced the plugin from a duplicate plugin module - check for duplicate modules in your 'node_modules' folder. The plugins that you requested to skip were: ${invalidSkipPlugins
            .map(getFunctionName)
            .join(", ")}`);
    }
    const finalPluginList = basePluginList.filter(p => skipPlugins.indexOf(p) === -1);
    return graphile_build_1.getBuilder(finalPluginList, Object.assign(Object.assign({ pgConfig, pgSchemas: Array.isArray(schemas) ? schemas : [schemas], pgExtendedTypes: !!dynamicJson, pgColumnFilter: pgColumnFilter || (() => true), pgInflection: inflector ||
            (classicIds ? exports.postGraphileClassicIdsInflection : exports.postGraphileInflection), nodeIdFieldName: nodeIdFieldName || (classicIds ? "id" : "nodeId"), pgJwtTypeIdentifier: jwtPgTypeIdentifier, pgJwtSecret: jwtSecret, pgJwtSignOptions: jwtSignOptions, pgDisableDefaultMutations: disableDefaultMutations, pgViewUniqueKey: viewUniqueKey, pgEnableTags: enableTags, pgLegacyRelations: legacyRelations, pgLegacyJsonUuid: legacyJsonUuid, persistentMemoizeWithKey, pgForbidSetofFunctionsToReturnNull: !setofFunctionsContainNulls, pgSimpleCollections: simpleCollections, pgIncludeExtensionResources: includeExtensionResources, pgIgnoreRBAC: ignoreRBAC, pgLegacyFunctionsOnly: legacyFunctionsOnly, pgIgnoreIndexes: ignoreIndexes, pgHideIndexWarnings: hideIndexWarnings, pgOwnerConnectionString: ownerConnectionString, 
        /*
         * `subscriptions` acts as a feature flag telling us to fetch all the
         * relevant database identifiers. We can't enable this by default in v4
         * because it's possible that someone has used column-level select grants
         * on a table in their DB but has not granted select access to one of their
         * primary key columns. This flag requires that if a table is selectable
         * then the PKs must be also.
         */
        subscriptions,
        live }, graphileBuildOptions), graphqlBuildOptions));
};
function abort(e) {
    // eslint-disable-next-line no-console
    console.error("Error occured whilst writing cache");
    // eslint-disable-next-line no-console
    console.error(e);
    process.exit(1);
}
exports.createPostGraphileSchema = async (pgConfig, schemas, options = {}) => {
    let writeCache;
    const builder = await exports.getPostGraphileBuilder(pgConfig, schemas, Object.assign(Object.assign({}, options), { setWriteCacheCallback(fn) {
            writeCache = fn;
        } }));
    const schema = builder.buildSchema();
    if (writeCache) {
        await writeCache().catch(abort);
    }
    return schema;
};
/*
 * Unless an error occurs, `onNewSchema` is guaranteed to be called before this promise resolves
 */
exports.watchPostGraphileSchema = async (pgConfig, schemas, options = {}, onNewSchema) => {
    if (typeof onNewSchema !== "function") {
        throw new Error("You cannot call watchPostGraphileSchema without a function to pass new schemas to");
    }
    if (options.readCache) {
        throw new Error("Using readCache in watch mode does not make sense.");
    }
    let writeCache;
    const builder = await exports.getPostGraphileBuilder(pgConfig, schemas, Object.assign(Object.assign({}, options), { setWriteCacheCallback(fn) {
            writeCache = fn;
        } }));
    let released = false;
    function handleNewSchema(schema) {
        if (writeCache) {
            writeCache().catch(abort);
        }
        onNewSchema(schema);
    }
    await builder.watchSchema(handleNewSchema);
    return async function release() {
        if (released) {
            return;
        }
        released = true;
        await builder.unwatchSchema();
    };
};
// Backwards compat
exports.postGraphQLBaseOverrides = exports.postGraphileBaseOverrides;
exports.postGraphQLClassicIdsOverrides = exports.postGraphileClassicIdsOverrides;
exports.postGraphQLInflection = exports.postGraphileInflection;
exports.postGraphQLClassicIdsInflection = exports.postGraphileClassicIdsInflection;
exports.createPostGraphQLSchema = exports.createPostGraphileSchema;
exports.watchPostGraphQLSchema = exports.watchPostGraphileSchema;
//# sourceMappingURL=index.js.map