import { QueryConfig } from "pg";
declare const $$trusted: unique symbol;
interface SQLRawNode {
    text: string;
    type: "RAW";
    [$$trusted]: true;
}
interface SQLIdentifierNode {
    names: Array<string | symbol>;
    type: "IDENTIFIER";
    [$$trusted]: true;
}
interface SQLValueNode {
    value: any;
    type: "VALUE";
    [$$trusted]: true;
}
export declare type SQLNode = SQLRawNode | SQLValueNode | SQLIdentifierNode;
export declare type SQLQuery = Array<SQLNode>;
export declare type SQL = SQLNode | SQLQuery;
export declare function compile(sql: SQLQuery | SQLNode): QueryConfig;
export declare function query(strings: TemplateStringsArray, ...values: Array<SQL>): SQLQuery;
/**
 * Creates a Sql item for some raw Sql text. Just plain ol‘ raw Sql. This
 * method is dangerous though because it involves no escaping, so proceed
 * with caution!
 */
export declare function raw(text: string): SQLNode;
/**
 * Creates a Sql item for a Sql identifier. A Sql identifier is anything like
 * a table, schema, or column name. An identifier may also have a namespace,
 * thus why many names are accepted.
 */
export declare function identifier(...names: Array<string | symbol>): SQLNode;
/**
 * Creates a Sql item for a value that will be included in our final query.
 * This value will be added in a way which avoids Sql injection.
 */
export declare function value(val: any): SQLNode;
declare const nullNode: SQLNode;
/**
 * If the value is simple will inline it into the query, otherwise will defer
 * to value.
 */
export declare function literal(val: string | number | boolean | null): SQLNode;
/**
 * Join some Sql items together seperated by a string. Useful when dealing
 * with lists of Sql items that doesn’t make sense as a Sql query.
 */
export declare function join(items: Array<SQL>, rawSeparator?: string): SQLQuery;
export declare function escapeSqlIdentifier(str: string): string;
export declare const blank: SQLQuery;
export { query as fragment, nullNode as null };
